<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spectre Protocol</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background-color: #0b0213;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
        }
        
        #main-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            min-height: 80px;
            background: linear-gradient(to top, rgba(11, 2, 19, 0.95), rgba(11, 2, 19, 0.6));
            backdrop-filter: blur(4px);
            border-top: 2px solid #ff007f;
            z-index: 20;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            box-shadow: 0 -5px 20px rgba(255, 0, 127, 0.2);
            pointer-events: none; /* Let touches pass through to controls below/above */
        }
        
        #ui-panel > * {
            pointer-events: auto; /* Re-enable clicks on buttons inside panel */
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffc8;
            font-family: monospace;
            font-size: 1.2rem;
            z-index: 50;
            text-shadow: 0 0 5px #00ffc8;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-radius: 4px;
            min-width: 200px;
        }
        
        #boss-hud {
            display: none;
            margin-top: 10px;
            border-top: 1px solid #ff007f;
            padding-top: 5px;
        }
        
        #boss-health-bar-container {
            width: 100%;
            height: 10px;
            background: #330011;
            border: 1px solid #ff007f;
            margin-top: 5px;
        }
        
        #boss-health-bar {
            width: 100%;
            height: 100%;
            background: #ff007f;
            box-shadow: 0 0 10px #ff007f;
            transition: width 0.2s;
        }
        
        .breach-warning {
            color: #ff007f;
            font-weight: bold;
            animation: pulse-red 1s infinite;
        }
        
        .powerup-active {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            animation: pulse-gold 0.5s infinite alternate;
        }
        
        @keyframes pulse-gold {
            from { opacity: 0.8; }
            to { opacity: 1; text-shadow: 0 0 20px #ffd700; }
        }

        @keyframes pulse-red {
            0% { opacity: 0.7; text-shadow: 0 0 5px #ff007f; }
            50% { opacity: 1; text-shadow: 0 0 15px #ff007f; }
            100% { opacity: 0.7; text-shadow: 0 0 5px #ff007f; }
        }

        h1 {
            color: #ff007f;
            text-shadow: 0 0 10px #ff007f;
            font-size: 1.5rem;
            margin: 0;
            font-family: monospace;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            color: #ff007f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            backdrop-filter: blur(5px);
            padding-bottom: 140px;
            box-sizing: border-box;
        }
        
        .glitch-text {
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: 4px;
            text-shadow: 2px 2px #00ffc8;
            animation: glitch-effect 0.2s infinite alternate-reverse;
            margin-bottom: 1rem;
        }
        
        @keyframes glitch-effect {
            0% { transform: translate(1px, 1px); text-shadow: 2px 2px #00ffc8; }
            25% { transform: translate(-1px, -1px); text-shadow: -2px 2px #ff007f; }
            50% { transform: translate(-1px, 1px); text-shadow: 2px -2px #00ffc8; }
            100% { transform: translate(1px, -1px); text-shadow: -2px -2px #ff007f; }
        }
        
        .neon-button {
            background: #0b0213;
            color: #00ffc8;
            padding: 1rem 2.5rem;
            border-radius: 4px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border: 2px solid #00ffc8;
            box-shadow: 0 0 10px #00ffc8, inset 0 0 10px #00ffc8;
            transition: all 0.2s;
            margin-top: 20px;
            font-family: monospace;
            letter-spacing: 2px;
        }
        
        .neon-button:hover {
            background: #00ffc8;
            color: #0b0213;
            box-shadow: 0 0 20px #00ffc8, inset 0 0 20px #00ffc8;
        }

        .control-btn {
            background: transparent;
            border: 1px solid #ff007f;
            color: #ff007f;
            padding: 0.4rem 1rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: 0.2s;
            font-family: monospace;
            margin-left: 10px;
        }
        
        .control-btn:hover {
            background: #ff007f;
            color: white;
        }
        
        .leaderboard {
            width: 90%;
            max-width: 450px;
            margin-top: 20px;
            border: 2px solid #00ffc8;
            box-shadow: 0 0 15px #00ffc8;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffc8;
            max-height: 30vh;
            overflow-y: auto;
        }

        .leaderboard h3 {
            background: #00ffc8;
            color: #0b0213;
            padding: 8px;
            margin: 0;
            font-size: 1.1rem;
            text-shadow: none;
            position: sticky;
            top: 0;
        }
        
        .leaderboard table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .leaderboard th, .leaderboard td {
            padding: 6px 10px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 255, 200, 0.2);
        }
        
        .leaderboard tr:nth-child(even) {
            background: rgba(0, 255, 200, 0.05);
        }

        .leaderboard tr:hover {
            background: rgba(255, 0, 127, 0.1);
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 80px; /* Raised to 80px to avoid iOS home bar and UI overlap */
            left: 0;
            width: 100%;
            height: 140px;
            z-index: 60;
            padding: 0 20px;
            box-sizing: border-box;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        #joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(0, 255, 200, 0.1);
            border: 2px solid rgba(0, 255, 200, 0.4);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            backdrop-filter: blur(2px);
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 200, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #00ffc8;
        }

        #fire-btn-mobile {
            width: 100px;
            height: 100px;
            background: rgba(255, 0, 127, 0.2);
            border: 3px solid #ff007f;
            border-radius: 50%;
            color: #ff007f;
            font-family: monospace;
            font-weight: bold;
            font-size: 1.2rem;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(255, 0, 127, 0.4);
            backdrop-filter: blur(2px);
            user-select: none;
            -webkit-user-select: none;
        }
        
        #fire-btn-mobile:active {
            background: rgba(255, 0, 127, 0.6);
            color: #fff;
            box-shadow: 0 0 30px #ff007f;
        }

        @media (max-width: 768px) {
            #ui-panel {
                flex-direction: column;
                padding: 0.5rem;
                gap: 0.25rem;
                min-height: 60px;
            }
            .control-group {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
            }
            .glitch-text { font-size: 2rem; }
            .leaderboard { width: 95%; }
            
            /* #mobile-controls { display: flex; }  -- Handled via JS now for broader support */
            #instructions .text-cyan-300 { display: none; } /* Hide keyboard instructions on mobile */
            
            h1 { font-size: 1.2rem; }
            #hud { font-size: 1rem; top: 10px; left: 10px; min-width: 150px; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
            }
        }
    </script>
</head>
<body>

<div id="main-container">
    <div id="game-container">
        <div id="hud">
            <div>SCORE: <span id="score-display">0</span></div>
            <div class="mt-2 text-red-400">BREACHES: <span id="missed-display">0</span>/3</div>
            <div id="powerup-display" class="text-sm mt-2 font-bold"></div>
            <div id="wave-display" class="text-xs mt-1 text-pink-500 opacity-80">PHASE: INITIALIZING</div>
            
            <!-- Boss HUD -->
            <div id="boss-hud">
                <div id="boss-name" class="text-[#ff2a00] font-bold text-sm tracking-widest">WARNING: BOSS DETECTED</div>
                <div id="boss-health-bar-container">
                    <div id="boss-health-bar"></div>
                </div>
            </div>
        </div>
        
        <div id="mobile-controls">
            <div id="joystick-container">
                <div id="joystick-knob"></div>
            </div>
            <button id="fire-btn-mobile">FIRE</button>
        </div>

        <div id="overlay-screen">
            <p class="glitch-text" id="overlay-title">SPECTRE PROTOCOL</p>
            
            <div id="form-container" class="hidden w-full max-w-sm flex flex-col items-center mt-4 mb-4">
                 <p class="text-[#00ffc8] font-mono text-sm mb-2 tracking-widest animate-pulse">NEW HIGH SCORE DETECTED</p>
                 <div class="flex gap-2 w-full justify-center">
                    <input id="agent-name-input" type="text" maxlength="12" 
                           class="bg-gray-900/80 border-2 border-[#ff007f] text-[#ff007f] px-3 py-2 font-mono text-center uppercase focus:outline-none focus:border-[#00ffc8] focus:shadow-[0_0_10px_#00ffc8] transition-all w-48 placeholder-pink-900" 
                           placeholder="AGENT_ID">
                    <button id="submit-score-btn" class="bg-[#ff007f]/20 border-2 border-[#ff007f] text-[#ff007f] px-4 py-2 font-mono hover:bg-[#ff007f] hover:text-black transition-all font-bold">
                        UPLOAD
                    </button>
                 </div>
            </div>

            <div id="leaderboard-display" class="leaderboard">
                <h3>TOP 10 INTERCEPTORS</h3>
                <table>
                    <thead><tr><th>Rank</th><th>Agent</th><th>Score</th></tr></thead>
                    <tbody id="leaderboard-body">
                        <tr><td colspan="3" class="text-center text-xs text-pink-400">Loading Neural Link...</td></tr>
                    </tbody>
                </table>
            </div>
            <div id="instructions" class="text-center mt-6">
                <p class="text-white font-mono text-sm max-w-md p-2 mx-auto">
                    MISSION: INTERCEPT INCOMING DATA BLOCKS.
                </p>
                <p class="text-pink-500 font-mono text-xs mb-4">
                    WARNING: ALLOWING 3 ENEMIES TO PASS RESULTS IN SYSTEM FAILURE.
                </p>
                <div class="text-cyan-300 text-xs font-mono mb-6">
                    MOVE: WASD / ARROWS | FIRE: HOLD SPACE / CLICK
                </div>
            </div>
            <button id="start-btn" class="neon-button">INITIATE PROTOCOL</button>
        </div>
    </div>
    
    <div id="ui-panel">
        <div class="flex flex-col items-start">
            <h1>SPECTRE PROTOCOL</h1>
            <p id="sys-version" class="text-xs text-cyan-600 font-mono">SYS.VER.9.8 // MOBILE OP</p>
        </div>
        <div class="text-center hidden md:block">
            <div class="text-xs text-pink-500 font-mono animate-pulse">DATABASE LINK ESTABLISHED</div>
        </div>
        <div class="control-group flex items-center">
            <button id="mute-btn" class="control-btn">MUTE AUDIO</button>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { CopyShader } from 'three/addons/shaders/CopyShader.js';
    import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';

    import { initializeApp } from 'firebase/app';
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
    import { getFirestore, collection, query, orderBy, limit, onSnapshot, addDoc, serverTimestamp, setLogLevel } from 'firebase/firestore';

    // --- CONFIGURATION ---
    // FIREBASE CONFIGURATION FOR MULTI-USER LEADERBOARDS
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyDV7eXu5ERIic4pdE99qfoiH-_-uELJEgw",
      authDomain: "spectreprotocol-c21c5.firebaseapp.com",
      projectId: "spectreprotocol-c21c5",
      storageBucket: "spectreprotocol-c21c5.firebasestorage.app",
      messagingSenderId: "964619451248",
      appId: "1:964619451248:web:0adbc90162d36db6412db5",
      measurementId: "G-WFK1184JWY"
    };
    
    const FirebaseState = {
        db: null,
        auth: null,
        userId: null
    };

    // Check if config is provided via injection (dev env) or via the constant above (prod/github pages)
    const injectedConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
    
    let activeConfig = {};
    if (injectedConfig && injectedConfig !== '{}') {
        activeConfig = JSON.parse(injectedConfig);
    } else if (Object.keys(FIREBASE_CONFIG).length > 0) {
        activeConfig = FIREBASE_CONFIG;
    }

    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    if (Object.keys(activeConfig).length > 0 && activeConfig.apiKey) {
        try {
            const app = initializeApp(activeConfig);
            FirebaseState.db = getFirestore(app);
            FirebaseState.auth = getAuth(app);
            setLogLevel('error');
        } catch (e) {
            console.error("Firebase Init Error:", e);
        }
    }

    async function initializeFirebase() {
        const auth = FirebaseState.auth;
        if (!auth) {
            // Explicitly trigger fallback if no auth
            setupLeaderboardListener();
            return;
        }
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase authentication failed:", error);
            FirebaseState.userId = crypto.randomUUID();
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                FirebaseState.userId = user.uid;
                setupLeaderboardListener();
            } else {
                FirebaseState.userId = crypto.randomUUID();
                setupLeaderboardListener();
            }
        });
    }

    function getScoresCollectionRef() {
        return collection(FirebaseState.db, `artifacts/${appId}/public/data/scores`);
    }

    function setupLeaderboardListener() {
        if (!FirebaseState.db) {
            // Local Storage Fallback
            console.log("Using Local Storage for Leaderboard");
            const localScores = JSON.parse(localStorage.getItem('spectre_local_leaderboard') || '[]');
            if (localScores.length === 0) {
                 // Initial Dummy Data so it looks cool
                 localScores.push(
                     {name: 'SPECTRE', score: 5000},
                     {name: 'GHOST', score: 3500},
                     {name: 'PHANTOM', score: 2000}
                 );
                 localStorage.setItem('spectre_local_leaderboard', JSON.stringify(localScores));
            }
            renderLeaderboard(localScores.sort((a, b) => b.score - a.score));
            
            document.getElementById('sys-version').innerText = "SYS.VER.9.8 // LOCAL STORAGE";
            return;
        }
        
        document.getElementById('sys-version').innerText = "SYS.VER.9.8 // CLOUD SYNC";
        const scoresQuery = query(getScoresCollectionRef(), orderBy('score', 'desc'), limit(10));
        
        onSnapshot(scoresQuery, (snapshot) => {
            renderLeaderboard(snapshot.docs.map(doc => doc.data()));
        }, (error) => {
            console.error("Leaderboard sync error:", error);
            // Fallback to local if cloud fails mid-game
            document.getElementById('sys-version').innerText = "SYS.VER.9.8 // SYNC ERROR";
        });
    }

    function renderLeaderboard(scores) {
        const body = document.getElementById('leaderboard-body');
        body.innerHTML = '';
        if (scores.length === 0) {
            body.innerHTML = `<tr><td colspan="3" class="text-center text-xs text-pink-400">No scores yet.</td></tr>`;
            return;
        }
        scores.forEach((s, index) => {
            const row = body.insertRow();
            row.insertCell(0).innerText = index + 1;
            row.insertCell(1).innerText = s.name ? s.name.substring(0, 12) : 'UNKNOWN';
            row.insertCell(2).innerText = s.score;
        });
    }

    function submitScore() {
        const input = document.getElementById('agent-name-input');
        const name = input.value.trim().toUpperCase() || 'ANONYMOUS';
        const finalScore = score;

        if (FirebaseState.db) {
            addDoc(getScoresCollectionRef(), {
                name: name,
                score: finalScore,
                timestamp: serverTimestamp(),
                userId: FirebaseState.userId,
            }).then(() => {
                 localStorage.setItem('spectre_agent_name', name);
                 resetOverlayToStart();
            }).catch(e => {
                console.error("Score upload failed", e);
                // Fallback to local
                saveLocalScore(name, finalScore);
                resetOverlayToStart();
            });
        } else {
            saveLocalScore(name, finalScore);
            resetOverlayToStart();
        }
    }
    
    function saveLocalScore(name, finalScore) {
        const localScores = JSON.parse(localStorage.getItem('spectre_local_leaderboard') || '[]');
        localScores.push({ name: name, score: finalScore, timestamp: Date.now() });
        localScores.sort((a, b) => b.score - a.score);
        const top10 = localScores.slice(0, 10);
        localStorage.setItem('spectre_local_leaderboard', JSON.stringify(top10));
        renderLeaderboard(top10);
        localStorage.setItem('spectre_agent_name', name);
    }
    
    function resetOverlayToStart() {
        document.getElementById('form-container').classList.add('hidden');
        const btn = document.getElementById('start-btn');
        btn.innerText = "RE-INITIALIZE";
        btn.style.display = 'block';
    }

    // --- FULL EDM AUDIO ENGINE ---
    const AudioSys = {
        ctx: null, isMuted: false, isPlaying: false,
        nextNoteTime: 0, tempo: 128, lookahead: 25.0, scheduleAheadTime: 0.1, timerID: null, measure: 0, beat: 0,
        
        init: function() {
            if (!this.ctx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            }
        },
        
        unlock: function() {
            if (!this.ctx) this.init();
            const buffer = this.ctx.createBuffer(1, 1, 22050);
            const source = this.ctx.createBufferSource();
            source.buffer = buffer;
            source.connect(this.ctx.destination);
            source.start(0);
            if (this.ctx.state === 'suspended') {
                this.ctx.resume().then(() => {
                    console.log("Audio Context Resumed via Unlock");
                });
            }
        },

        toggleMute: function() {
            this.isMuted = !this.isMuted;
            if (this.isMuted) { if(this.ctx) this.ctx.suspend(); } 
            else { if(this.ctx) this.ctx.resume(); }
            return this.isMuted;
        },
        
        playTone: function(freq, type, len, time, vol=0.1) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(vol, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + len);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + len);
        },

        playNoise: function(len, filterFreq, time) {
            if (this.isMuted || !this.ctx) return;
            const bufferSize = this.ctx.sampleRate * len;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = filterFreq;
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + len);
            noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            noise.start(time);
        },
        
        playKick: function(time) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.5);
        },
        
        playSnare: function(time) { this.playNoise(0.1, 1000, time); },
        playHiHat: function(time, open = false) { this.playNoise(open ? 0.1 : 0.05, 8000, time); },

        playBass: function(time, freq, intensity = 0) {
             if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, time);
            filter.type = 'lowpass';
            const baseFreq = 200 + (intensity * 2000);
            filter.frequency.setValueAtTime(baseFreq, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + 0.2);
            gain.gain.setValueAtTime(0.15, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
            osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.3);
        },

        playLead: function(time, freq) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(freq, time);
            osc.frequency.linearRampToValueAtTime(freq + 5, time + 0.1);
            gain.gain.setValueAtTime(0.05, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.3);
        },

        // Riser for build ups
        playRiser: function(time, pitch) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(pitch, time);
            osc.frequency.linearRampToValueAtTime(pitch + 100, time + 0.1);
            gain.gain.setValueAtTime(0.05, time);
            gain.gain.linearRampToValueAtTime(0.01, time + 0.1);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.1);
        },
        
        scheduleNote: function(beatNumber, time) {
            const gameTime = (performance.now() - gameStartTime) / 1000;
            
            const phaseInterval = 30; 
            const timeInPhase = gameTime % phaseInterval;
            const isBuildUp = (timeInPhase > 26 && gameTime > 10); // Last 4 seconds of any phase is a build up
            
            if (isBuildUp) {
                let playRoll = false;
                if (timeInPhase < 28 && beatNumber % 4 === 0) playRoll = true;
                else if (timeInPhase >= 28 && timeInPhase < 29 && beatNumber % 2 === 0) playRoll = true;
                else if (timeInPhase >= 29) playRoll = true;
                
                if (playRoll) {
                    this.playSnare(time);
                    this.playRiser(time, 200 + (timeInPhase - 26) * 200); // Rising pitch
                }
                return; 
            }

            // Kick
            if (beatNumber % 4 === 0) this.playKick(time);
            
            // Snare (Backbeat)
            if (beatNumber === 4 || beatNumber === 12) this.playSnare(time);
            
            // HiHats
            if (gameTime > 10) {
                if (gameTime > 60) { // Overdrive hats
                     this.playHiHat(time, beatNumber % 4 === 2); // Open hat on off-beat
                     if (beatNumber % 2 !== 0) this.playHiHat(time, false); // Closed hats in between
                } else if (gameTime > 30) { // Hard hats
                    this.playHiHat(time, beatNumber % 4 === 2);
                } else if (beatNumber % 2 === 0) {
                    this.playHiHat(time);
                }
            }
            
            // Bass
            if (gameTime > 5) {
                 const bassRoot = [55, 55, 65.4, 43.6][Math.floor((this.measure % 4))]; 
                 const bassIntensity = Math.min(1, gameTime / 90);
                 
                 // Syncopated bass rhythm
                 if (beatNumber === 0 || beatNumber === 3 || beatNumber === 7 || beatNumber === 10) {
                     this.playBass(time, bassRoot, bassIntensity);
                 }
            }
            
            // Lead Arp (Enter in Hard Phase)
            if (gameTime > 30 && beatNumber % 2 === 0) {
                const arpNotes = [440, 523, 659, 880];
                if (gameTime > 60 || Math.random() > 0.5) {
                    this.playLead(time, arpNotes[Math.floor(Math.random()*arpNotes.length)]);
                }
            }
        },
        
        scheduler: function() {
            while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.beat, this.nextNoteTime);
                const secondsPerBeat = 60.0 / this.tempo / 4;
                this.nextNoteTime += secondsPerBeat;
                this.beat++;
                if (this.beat === 16) { this.beat = 0; this.measure++; }
            }
            this.timerID = window.setTimeout(this.scheduler.bind(this), this.lookahead);
        },
        start: function() {
            if (this.isPlaying) return;
            this.isPlaying = true; this.beat = 0; this.measure = 0;
            this.tempo = 128; // Reset tempo
            this.nextNoteTime = this.ctx.currentTime + 0.1;
            this.scheduler();
        },
        stop: function() {
            this.isPlaying = false; window.clearTimeout(this.timerID);
        },
        
        playLaser: function() { 
            if (this.isMuted || !this.ctx) return;
            const time = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            // Percussive Beat Laser (Kick/Tom Style)
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(350, time);
            osc.frequency.exponentialRampToValueAtTime(60, time + 0.15);
            
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
            
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.15);
        },

        playExplosion: function() {
             if (this.isMuted || !this.ctx) return;
             for(let i=0; i<3; i++) {
                 this.playBass(this.ctx.currentTime, 30 + Math.random() * 40, 1.0); 
             }
        },
        playBreach: function() {
            if (this.isMuted || !this.ctx) return;
            this.playTone(150, 'sawtooth', 0.5, this.ctx.currentTime, 0.5);
        },
        playPowerUp: function() {
             if (this.isMuted || !this.ctx) return;
             // High pitched chime
             this.playTone(880, 'sine', 0.1, this.ctx.currentTime, 0.2);
             this.playTone(1100, 'sine', 0.2, this.ctx.currentTime + 0.1, 0.2);
        },
        playShieldBreak: function() {
             if (this.isMuted || !this.ctx) return;
             this.playNoise(0.3, 500, this.ctx.currentTime);
        },
        playBossSpawn: function() {
            if (this.isMuted || !this.ctx) return;
            this.playTone(100, 'sawtooth', 1.5, this.ctx.currentTime, 1.0);
            this.playTone(80, 'sawtooth', 1.5, this.ctx.currentTime, 1.0);
        }
    };

    let scene, camera, renderer, composer, rgbPass;
    let player, shieldMesh, groundMesh1, groundMesh2;
    let boss = null;
    let nextBossScoreThreshold = 5000;
    
    const lasers = [];
    const enemies = [];
    const particles = [];
    const powerUps = [];
    
    const keys = { left: false, right: false, up: false, down: false, fire: false };
    let isFiring = false;
    let lastFireTime = 0;
    
    let score = 0, missedEnemies = 0, isGameOver = false, isGameRunning = false, gameStartTime = 0;
    let currentPhase = 0; // 0: Init, 1: Normal, 2: Hard, 3: Overdrive
    let spawnInterval = 2500, lastEnemySpawnTime = 0, lastPowerUpSpawnTime = 0;
    let targetX = 0;
    let targetY = -1.0; // Vertical target
    let shakeIntensity = 0;
    
    // Player State
    const playerState = {
        shield: false,
        activePowerUp: 'NONE', // NONE, RAPID, SPREAD
        powerUpEndTime: 0
    };
    
    const COLORS = { 
        cyan: 0x00ffc8, 
        pink: 0xff007f, 
        dark: 0x0b0213, 
        neonGreen: 0x00ff41, 
        neonCyan: 0x00ffff,
        neonMagenta: 0xff00ff,
        darkGreen: 0x004411,
        gold: 0xffd700,
        white: 0xffffff,
        neonYellow: 0xffff00
    };
    const GROUND_SIZE = 200;
    
    const ENEMY_CONFIGS = [
        { name: 'STANDARD', color: 0xff007f, speed: 1.0, rot: {x: 0.02, y: 0.02}, score: 100 },
        { name: 'FAST', color: 0x00ffc8, speed: 1.5, rot: {x: 0.0, y: 0.1}, score: 150 },
        { name: 'HEAVY', color: 0xff2a00, speed: 0.7, rot: {x: 0.005, y: 0.005}, score: 200 }
    ];
    
    const BOSS_CONFIGS = [
        { name: "THE MONOLITH", type: 'CUBE', color: 0xff007f, hp: 30, score: 1000 },
        { name: "THE PRISM", type: 'TETRA', color: 0x00ffc8, hp: 20, score: 2000 },
        { name: "THE HIVE", type: 'ICO', color: 0xffd700, hp: 50, score: 3000 }
    ];
    
    const POWERUP_TYPES = [
        { name: 'RAPID', color: COLORS.gold, label: "RAPID FIRE" },
        { name: 'SPREAD', color: COLORS.neonCyan, label: "SPREAD SHOT" },
        { name: 'SHIELD', color: COLORS.white, label: "SHIELD" }
    ];

    function init() {
        initializeFirebase();
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.dark);
        scene.fog = new THREE.FogExp2(COLORS.dark, 0.02); 

        camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.0, 6); 
        camera.rotation.x = -0.1;

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(COLORS.pink, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(COLORS.pink, 1);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        createGround();
        createPlayerShip();
        createStarfield();
        setupPostProcessing(container.clientWidth, container.clientHeight);
        setupMobileControls();

        window.addEventListener('resize', onWindowResize);
        
        // Desktop Mouse Input
        container.addEventListener('mousemove', (e) => {
             // Only process mouse move if not touching (to avoid conflict with touch emulation)
             if(e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
             
             const rect = renderer.domElement.getBoundingClientRect();
             targetX = ((e.clientX - rect.left) / rect.width * 2 - 1) * 8;
             targetY = -((e.clientY - rect.top) / rect.height * 2 - 1) * 4 + 1;
             targetY = Math.max(-1.5, Math.min(3.5, targetY));
        });
        container.addEventListener('mousedown', () => { keys.fire = true; });
        container.addEventListener('mouseup', () => { keys.fire = false; });
        
        // Global Touch for Audio Unlock
        document.addEventListener('touchstart', () => {
             if(AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.unlock();
        }, {once: true});

        // Keyboard Input
        window.addEventListener('keydown', (e) => {
            if(!isGameRunning) return;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') { keys.left = true; }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') { keys.right = true; }
            if (e.code === 'ArrowUp' || e.code === 'KeyW') { keys.up = true; }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') { keys.down = true; }
            if (e.code === 'Space') { keys.fire = true; e.preventDefault(); }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
            if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
            if (e.code === 'Space') keys.fire = false;
        });

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('submit-score-btn').addEventListener('click', submitScore);
        
        document.getElementById('mute-btn').addEventListener('click', (e) => {
            e.target.innerText = AudioSys.toggleMute() ? "UNMUTE AUDIO" : "MUTE AUDIO";
        });
        
        const savedName = localStorage.getItem('spectre_agent_name');
        if(savedName) document.getElementById('agent-name-input').value = savedName;
        
        setTimeout(() => {
            if (!FirebaseState.db) {
                setupLeaderboardListener();
            }
        }, 1000);

        animate(0);
    }
    
    function setupMobileControls() {
        // Check if touch device regardless of screen width to support iPads/Tablets
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        if (isTouch) {
            // Force display controls
            const controls = document.getElementById('mobile-controls');
            controls.style.display = 'flex';
            
            // Hide desktop-specific text
            const desktopInstr = document.querySelector('#instructions .text-cyan-300');
            if(desktopInstr) desktopInstr.style.display = 'none';
            
            const joystickContainer = document.getElementById('joystick-container');
            const joystickKnob = document.getElementById('joystick-knob');
            const fireBtn = document.getElementById('fire-btn-mobile');
            
            // Joystick Logic
            let touchId = null;
            const maxRadius = 35; // limit knob movement
            
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if(touchId !== null) return;
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                updateJoystick(touch);
            });
            
            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        updateJoystick(e.changedTouches[i]);
                        break;
                    }
                }
            });
            
            const resetJoystick = (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        touchId = null;
                        joystickKnob.style.transform = `translate(-50%, -50%)`;
                        break;
                    }
                }
            };
            
            joystickContainer.addEventListener('touchend', resetJoystick);
            joystickContainer.addEventListener('touchcancel', resetJoystick);
            
            function updateJoystick(touch) {
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
                const angle = Math.atan2(dy, dx);
                
                const knobX = Math.cos(angle) * distance;
                const knobY = Math.sin(angle) * distance;
                
                joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
                
                const normX = knobX / maxRadius;
                const normY = knobY / maxRadius; 
                
                targetX = normX * 8.0;
                targetY = 1.0 + (-normY * 2.5);
                
                targetX = Math.max(-8, Math.min(8, targetX));
                targetY = Math.max(-1.5, Math.min(3.5, targetY));
            }
            
            // Fire Button Logic
            fireBtn.addEventListener('touchstart', (e) => {
                 e.preventDefault();
                 keys.fire = true;
                 fireBtn.style.background = "rgba(255, 0, 127, 0.6)";
            });
            
            fireBtn.addEventListener('touchend', (e) => {
                 e.preventDefault();
                 keys.fire = false;
                 fireBtn.style.background = "rgba(255, 0, 127, 0.2)";
            });
        }
    }

    function setupPostProcessing(w, h) {
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(w, h), 0.75, 0.5, 0.2));
        rgbPass = new ShaderPass(RGBShiftShader);
        rgbPass.uniforms['amount'].value = 0.0015; 
        composer.addPass(rgbPass);
        composer.addPass(new ShaderPass(CopyShader));
    }

    function createGround() {
        const width = 150;
        const length = GROUND_SIZE;
        const segmentsW = 50;
        const segmentsH = 50;
        const geo = new THREE.PlaneGeometry(width, length, segmentsW, segmentsH);
        
        const posAttribute = geo.attributes.position;
        const vertex = new THREE.Vector3();
        
        for (let i = 0; i < posAttribute.count; i++) {
            vertex.fromBufferAttribute(posAttribute, i);
            const distFromCenter = Math.abs(vertex.x);
            const safeZone = 15; 
            
            if (distFromCenter > safeZone) {
                const rise = Math.pow((distFromCenter - safeZone) / 4, 2.5);
                const noise = Math.random() * 2.5;
                vertex.z += rise + noise;
            }
            posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        geo.computeVertexNormals();

        const mat = new THREE.MeshBasicMaterial({ 
            color: COLORS.neonGreen, 
            wireframe: true, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3
        });

        groundMesh1 = new THREE.Mesh(geo, mat);
        groundMesh1.rotation.x = -Math.PI / 2;
        groundMesh1.position.set(0, -2, -GROUND_SIZE/2 + 6); 
        scene.add(groundMesh1);

        groundMesh2 = new THREE.Mesh(geo, mat);
        groundMesh2.rotation.x = -Math.PI / 2;
        groundMesh2.position.set(0, -2, -GROUND_SIZE/2 + 6 - GROUND_SIZE); 
        scene.add(groundMesh2);
    }

    function updateGround(delta) {
        const speed = 20 * delta;
        groundMesh1.position.z += speed;
        groundMesh2.position.z += speed;

        if (groundMesh1.position.z > 6 + GROUND_SIZE/2) groundMesh1.position.z -= GROUND_SIZE * 2;
        if (groundMesh2.position.z > 6 + GROUND_SIZE/2) groundMesh2.position.z -= GROUND_SIZE * 2;
    }
    
    function setPhase(p) {
        currentPhase = p;
        const hud = document.getElementById('wave-display');
        
        if (p === 1) {
            hud.innerText = "PHASE: PROTOCOL START";
            hud.className = "text-xs mt-1 text-[#00ff41] opacity-80";
            groundMesh1.material.color.setHex(COLORS.neonGreen);
            AudioSys.tempo = 128;
        } else if (p === 2) {
            hud.innerText = "PHASE: HARDLINE";
            hud.className = "text-xs mt-1 text-[#00ffff] opacity-100 font-bold";
            groundMesh1.material.color.setHex(COLORS.neonCyan);
            AudioSys.tempo = 138;
            composer.passes[1].strength = 3.0; 
            setTimeout(() => { composer.passes[1].strength = 0.75; }, 500);
        } else if (p === 3) {
            hud.innerText = "PHASE: SYSTEM OVERDRIVE";
            hud.className = "text-xs mt-1 text-[#ff00ff] opacity-100 font-bold animate-pulse";
            groundMesh1.material.color.setHex(COLORS.neonMagenta);
            AudioSys.tempo = 150;
            composer.passes[1].strength = 4.0;
            setTimeout(() => { composer.passes[1].strength = 0.75; }, 500);
        }
    }
    
    function checkPhaseLogic(now) {
        const time = (now - gameStartTime) / 1000;
        if (time < 30) { if (currentPhase !== 1) setPhase(1); } 
        else if (time < 60) { if (currentPhase !== 2) setPhase(2); } 
        else { if (currentPhase !== 3) setPhase(3); }
    }

    function createStarfield() {
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<2000; i++) pos.push((Math.random()-0.5)*200, (Math.random()-0.5)*100, (Math.random()-0.5)*200);
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({size: 0.1, color: 0xffffff});
        scene.add(new THREE.Points(geo, mat));
    }

    function createPlayerShip() {
        const group = new THREE.Group();
        
        // 1. Main Fuselage (Sleek Cone)
        const bodyGeo = new THREE.ConeGeometry(0.45, 1.8, 32);
        const bodyMat = new THREE.MeshBasicMaterial({ color: 0xff007f }); // Pink main body
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.rotation.x = -Math.PI / 2; // Point forward (Negative Z)
        group.add(body);

        // 2. Cockpit Detail
        const cockpitGeo = new THREE.BoxGeometry(0.25, 0.15, 0.5);
        const cockpitMat = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan glass
        const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
        cockpit.position.set(0, 0.3, 0.2);
        group.add(cockpit);

        // 3. Green Side Boosters
        const boosterGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.0, 16);
        const boosterMat = new THREE.MeshBasicMaterial({ color: 0x333333 }); // Dark grey housing

        // Glow Emitters (Green)
        const glowGeo = new THREE.CircleGeometry(0.14, 16);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff41 }); // Neon Green

        // Left Booster
        const bL = new THREE.Mesh(boosterGeo, boosterMat);
        bL.rotation.x = -Math.PI / 2;
        bL.position.set(-0.6, 0, 0.5);
        group.add(bL);

        const gL = new THREE.Mesh(glowGeo, glowMat);
        gL.position.set(0, -0.51, 0); // Bottom of cylinder (which is back after rotation)
        gL.rotation.x = Math.PI / 2;
        bL.add(gL);

        // Right Booster
        const bR = new THREE.Mesh(boosterGeo, boosterMat);
        bR.rotation.x = -Math.PI / 2;
        bR.position.set(0.6, 0, 0.5);
        group.add(bR);

        const gR = new THREE.Mesh(glowGeo, glowMat);
        gR.position.set(0, -0.51, 0);
        gR.rotation.x = Math.PI / 2;
        bR.add(gR);

        // 4. Wings/Struts (Connect boosters to body)
        const wingGeo = new THREE.BoxGeometry(1.2, 0.05, 0.4);
        const wingMat = new THREE.MeshBasicMaterial({ color: 0xff007f });
        const wing = new THREE.Mesh(wingGeo, wingMat);
        wing.position.set(0, 0, 0.5);
        group.add(wing);
        
        // Shield Mesh Group (RGB Wireframe)
        const shieldGroup = new THREE.Group();
        const geo = new THREE.IcosahedronGeometry(0.75, 1);
        
        // Red Layer
        const matR = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
        const shieldR = new THREE.Mesh(geo, matR);
        shieldGroup.add(shieldR);

        // Green Layer
        const matG = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
        const shieldG = new THREE.Mesh(geo, matG);
        shieldG.scale.setScalar(1.01); 
        shieldGroup.add(shieldG);

        // Blue Layer
        const matB = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
        const shieldB = new THREE.Mesh(geo, matB);
        shieldB.scale.setScalar(1.02); 
        shieldGroup.add(shieldB);
        
        shieldMesh = shieldGroup;
        shieldMesh.visible = false;
        group.add(shieldMesh);

        player = group;
        player.position.set(0, -1.0, 0);
        scene.add(player);
    }

    function createBossMesh(config) {
        const group = new THREE.Group();
        let mainMesh;
        
        if (config.type === 'CUBE') {
            // The Monolith
            const geo = new THREE.BoxGeometry(4, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: config.color, wireframe: true });
            mainMesh = new THREE.Mesh(geo, mat);
            
            const core = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), new THREE.MeshBasicMaterial({color: 0xffffff}));
            group.add(core);
        } else if (config.type === 'TETRA') {
            // The Prism
            const geo = new THREE.TetrahedronGeometry(3.5, 0);
            const mat = new THREE.MeshBasicMaterial({ color: config.color, wireframe: true });
            mainMesh = new THREE.Mesh(geo, mat);
            
            const rings = new THREE.Mesh(new THREE.TorusGeometry(3, 0.1, 8, 50), new THREE.MeshBasicMaterial({color: 0xffffff}));
            rings.rotation.x = Math.PI/2;
            group.add(rings);
        } else {
            // The Hive
            const geo = new THREE.IcosahedronGeometry(3, 1);
            const mat = new THREE.MeshBasicMaterial({ color: config.color, wireframe: true });
            mainMesh = new THREE.Mesh(geo, mat);
            
            // Spikes
            for(let i=0; i<6; i++) {
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2, 4), new THREE.MeshBasicMaterial({color: config.color}));
                spike.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);
                spike.lookAt(0,0,0);
                group.add(spike);
            }
        }
        
        group.add(mainMesh);
        
        // Add Data Streams
        const particles = new THREE.Points(
            new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(100*3).map(() => (Math.random()-0.5)*6), 3)),
            new THREE.PointsMaterial({color: config.color, size: 0.1})
        );
        group.add(particles);

        return group;
    }

    function spawnBoss() {
        AudioSys.playBossSpawn();
        const config = BOSS_CONFIGS[Math.floor(Math.random() * BOSS_CONFIGS.length)];
        
        const mesh = createBossMesh(config);
        mesh.position.set(0, 0, -100); // Start far away
        
        mesh.userData = {
            isBoss: true,
            hp: config.hp,
            maxHp: config.hp,
            score: config.score,
            name: config.name,
            movePhase: 0,
            lastSpawn: 0
        };
        
        boss = mesh;
        scene.add(boss);
        
        // Update HUD
        document.getElementById('boss-hud').style.display = 'block';
        document.getElementById('boss-name').innerText = `WARNING: ${config.name} DETECTED`;
        document.getElementById('boss-health-bar').style.width = '100%';
        
        nextBossScoreThreshold += 5000; // Next boss target
    }
    
    function destroyBoss() {
        AudioSys.playExplosion();
        AudioSys.playExplosion();
        
        // Massive particle explosion
        for(let i=0; i<5; i++) {
            spawnParticles(boss.position, boss.children[0].material.color);
        }
        
        shakeIntensity += 2.0;
        score += boss.userData.score;
        scene.remove(boss);
        boss = null;
        
        // Hide HUD
        document.getElementById('boss-hud').style.display = 'none';
        updateUI();
    }

    function createLaser(offsetX = 0, angleZ = 0) {
        AudioSys.playLaser();
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.5), new THREE.MeshBasicMaterial({color: 0xccffff})); 
        l.position.copy(player.position);
        l.position.x += offsetX;
        l.position.z -= 1;
        l.rotation.y = -angleZ; // Rotate to angle
        l.userData.velocity = new THREE.Vector3(Math.sin(angleZ) * 20, 0, -Math.cos(angleZ) * 20); // Calc velocity based on angle
        lasers.push(l);
        scene.add(l);
        
        shakeIntensity += 0.02;
    }
    
    function spawnPowerUp() {
        const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
        
        let mesh;
        
        if (type.name === 'SHIELD') {
             // RGB Pulsating Sphere
             mesh = new THREE.Group();
             const geo = new THREE.IcosahedronGeometry(0.5, 1);
             
             // Red
             const matR = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
             const mR = new THREE.Mesh(geo, matR);
             mesh.add(mR);
             
             // Green
             const matG = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
             const mG = new THREE.Mesh(geo, matG);
             mG.scale.setScalar(0.85);
             mesh.add(mG);
             
             // Blue
             const matB = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
             const mB = new THREE.Mesh(geo, matB);
             mB.scale.setScalar(0.7);
             mesh.add(mB);
             
             // White core
             const core = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), new THREE.MeshBasicMaterial({color: 0xffffff}));
             mesh.add(core);
             
             mesh.userData.isRGB = true;
        } else {
            const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const mat = new THREE.MeshBasicMaterial({ color: type.color, wireframe: true });
            mesh = new THREE.Mesh(geo, mat);
            
            // Inner core
            const core = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({ color: type.color }));
            mesh.add(core);
        }
        
        mesh.position.set((Math.random()-0.5)*8, -1.0, -100);
        
        // Set UserData
        mesh.userData.type = type.name;
        mesh.userData.label = type.label;
        mesh.userData.color = type.color;
        
        powerUps.push(mesh);
        scene.add(mesh);
        lastPowerUpSpawnTime = performance.now();
    }
    
    function activatePowerUp(powerUpData) {
        AudioSys.playPowerUp();
        const hud = document.getElementById('powerup-display');
        hud.innerText = powerUpData.label;
        hud.style.color = '#' + powerUpData.color.toString(16);
        hud.className = "text-sm mt-2 font-bold powerup-active";
        
        // Particles
        spawnParticles(player.position, powerUpData.color);
        
        if (powerUpData.type === 'SHIELD') {
            playerState.shield = true;
            shieldMesh.visible = true;
            setTimeout(() => { hud.innerText = ""; }, 2000);
        } else {
            playerState.activePowerUp = powerUpData.type;
            playerState.powerUpEndTime = performance.now() + 10000; // 10 seconds
        }
    }

    function spawnEnemy(startPos = null, isBossMinion = false) {
        let geometry, mat, speedMult, rotSpeed, scoreVal;
        
        if (isBossMinion) {
            // Boss Bullets: Slow, bright, smaller
            geometry = new THREE.OctahedronGeometry(0.4, 0);
            mat = new THREE.MeshBasicMaterial({ color: COLORS.neonYellow });
            speedMult = 0.09; // Slowed down considerably
            rotSpeed = {x: 0.1, y: 0.1};
            scoreVal = 50;
        } else {
            const typeConfig = ENEMY_CONFIGS[Math.floor(Math.random() * ENEMY_CONFIGS.length)];
            if (typeConfig.name === 'STANDARD') geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            else if (typeConfig.name === 'FAST') geometry = new THREE.OctahedronGeometry(0.6, 0);
            else geometry = new THREE.IcosahedronGeometry(0.7, 0);
            
            mat = new THREE.MeshBasicMaterial({ color: typeConfig.color });
            speedMult = typeConfig.speed;
            rotSpeed = typeConfig.rot;
            scoreVal = typeConfig.score;
        }

        const mesh = new THREE.Mesh(geometry, mat);
        
        const edges = new THREE.LineSegments(
            new THREE.EdgesGeometry(geometry), 
            new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 })
        );
        mesh.add(edges);

        mesh.userData = { 
            speedMult: speedMult, 
            rotSpeed: rotSpeed,
            scoreVal: scoreVal 
        };
        
        if (startPos) {
            mesh.position.copy(startPos);
        } else {
            mesh.position.set((Math.random()-0.5)*10, -1.0, -100);
        }
        
        enemies.push(mesh);
        scene.add(mesh);
        lastEnemySpawnTime = performance.now();
    }
    
    function spawnParticles(pos, color) {
        const count = 12;
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            mesh.userData.rotSpeed = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
            );
            mesh.userData.life = 1.0;
            scene.add(mesh);
            particles.push(mesh);
        }
    }
    
    function spawnShieldShatter(pos) {
        const count = 24;
        const geo = new THREE.ConeGeometry(0.2, 0.5, 3); // Shard shape
        const mat = new THREE.MeshBasicMaterial({ color: COLORS.neonCyan, transparent: true });
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            
            // Randomize starting position slightly to form a sphere
            const angle = Math.random() * Math.PI * 2;
            const z = (Math.random() - 0.5) * 2;
            const r = Math.sqrt(1 - z*z);
            mesh.position.x += r * Math.cos(angle) * 1.2;
            mesh.position.y += r * Math.sin(angle) * 1.2;
            mesh.position.z += z * 1.2;

            // Explode outwards from center
            mesh.userData.velocity = new THREE.Vector3(
                mesh.position.x - pos.x,
                mesh.position.y - pos.y,
                mesh.position.z - pos.z
            ).normalize().multiplyScalar(Math.random() * 0.5 + 0.2);

            mesh.lookAt(pos); // Point inwards/outwards
            
            mesh.userData.rotSpeed = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            mesh.userData.life = 1.5; // Last slightly longer
            scene.add(mesh);
            particles.push(mesh);
        }
    }

    function checkCollisions() {
        const pBox = new THREE.Box3().setFromObject(player);
        
        // Player vs Powerups
        for (let i = powerUps.length - 1; i >= 0; i--) {
            if (pBox.intersectsBox(new THREE.Box3().setFromObject(powerUps[i]))) {
                activatePowerUp(powerUps[i].userData);
                scene.remove(powerUps[i]);
                powerUps.splice(i, 1);
            }
        }
        
        // Boss Collision (Player crashes into Boss)
        if (boss) {
            if (pBox.intersectsBox(new THREE.Box3().setFromObject(boss))) {
                AudioSys.playExplosion();
                gameOver("BOSS COLLISION DETECTED");
            }
        }

        // Lasers vs Enemies & Boss
        for (let i = lasers.length - 1; i >= 0; i--) {
            const lBox = new THREE.Box3().setFromObject(lasers[i]);
            let laserHit = false;
            
            // Check Boss Hit
            if (boss && !laserHit) {
                 if (lBox.intersectsBox(new THREE.Box3().setFromObject(boss))) {
                     boss.userData.hp--;
                     AudioSys.playBass(AudioSys.ctx.currentTime, 50, 1.0); // Thud sound
                     
                     // Update Health Bar
                     const pct = (boss.userData.hp / boss.userData.maxHp) * 100;
                     document.getElementById('boss-health-bar').style.width = pct + '%';
                     
                     // Flash Boss
                     boss.children[0].material.color.setHex(0xffffff);
                     setTimeout(() => { 
                         if(boss) boss.children[0].material.color.setHex(COLORS.pink); // Reset color (could use stored original)
                     }, 50);
                     
                     spawnParticles(lasers[i].position, COLORS.white);
                     
                     if (boss.userData.hp <= 0) {
                         destroyBoss();
                     }
                     
                     scene.remove(lasers[i]); lasers.splice(i, 1);
                     laserHit = true;
                 }
            }
            
            if (laserHit) continue;

            for (let j = enemies.length - 1; j >= 0; j--) {
                if (lBox.intersectsBox(new THREE.Box3().setFromObject(enemies[j]))) {
                    AudioSys.playExplosion();
                    spawnParticles(enemies[j].position, enemies[j].material.color);
                    shakeIntensity += 0.1;
                    const enemyScore = enemies[j].userData.scoreVal || 100;
                    scene.remove(enemies[j]); enemies.splice(j, 1);
                    scene.remove(lasers[i]); lasers.splice(i, 1);
                    score += enemyScore; updateUI();
                    break;
                }
            }
        }
        
        // Player vs Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            if (pBox.intersectsBox(new THREE.Box3().setFromObject(enemies[i]))) {
                if (playerState.shield) {
                    // Shield Hit
                    AudioSys.playShieldBreak();
                    playerState.shield = false;
                    shieldMesh.visible = false;
                    spawnShieldShatter(player.position); // New shatter effect
                    spawnParticles(enemies[i].position, enemies[i].material.color);
                    
                    scene.remove(enemies[i]); enemies.splice(i, 1);
                    shakeIntensity += 0.8;
                    if(rgbPass) rgbPass.uniforms['amount'].value = 0.03;
                } else {
                    // Fatal Hit
                    AudioSys.playExplosion();
                    shakeIntensity += 1.0; 
                    if(rgbPass) rgbPass.uniforms['amount'].value = 0.1;
                    gameOver("IMPACT DETECTED");
                }
            }
        }
    }

    function updateUI() {
        document.getElementById('score-display').innerText = score;
        document.getElementById('missed-display').innerText = missedEnemies;
    }

    function gameOver(reason) {
        isGameOver = true; isGameRunning = false;
        AudioSys.stop();
        document.getElementById('overlay-title').innerText = `${reason}\nSCORE: ${score}`;
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('form-container').classList.remove('hidden');
        document.getElementById('agent-name-input').focus();
        document.getElementById('overlay-screen').style.display = 'flex';
        document.getElementById('instructions').style.display = 'none';
    }

    function startGame() {
        AudioSys.unlock(); 
        AudioSys.init(); 
        AudioSys.start();
        isGameOver = false; isGameRunning = true;
        score = 0; missedEnemies = 0; gameStartTime = performance.now();
        currentPhase = 0;
        shakeIntensity = 0;
        playerState.shield = false;
        playerState.activePowerUp = 'NONE';
        shieldMesh.visible = false;
        document.getElementById('powerup-display').innerText = "";
        targetX = 0;
        targetY = -1.0;
        
        // Reset Boss
        if (boss) { scene.remove(boss); boss = null; }
        document.getElementById('boss-hud').style.display = 'none';
        nextBossScoreThreshold = 5000;
        
        if(rgbPass) rgbPass.uniforms['amount'].value = 0.0015;
        setPhase(1); // Reset to green
        
        updateUI();
        document.getElementById('overlay-screen').style.display = 'none';
        enemies.forEach(e => scene.remove(e)); enemies.length = 0;
        lasers.forEach(l => scene.remove(l)); lasers.length = 0;
        particles.forEach(p => scene.remove(p)); particles.length = 0;
        powerUps.forEach(p => scene.remove(p)); powerUps.length = 0;
        player.position.set(0, -1.0, 0);
        
    }

    function onWindowResize() {
        const c = document.getElementById('game-container');
        camera.aspect = c.clientWidth / c.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(c.clientWidth, c.clientHeight);
        composer.setSize(c.clientWidth, c.clientHeight);
    }

    let lastTime = 0;
    function animate(time) {
        requestAnimationFrame(animate);
        if(!lastTime) { lastTime = time; return; }
        const delta = (time - lastTime) / 1000;
        lastTime = time;

        updateGround(delta);

        if (isGameRunning) {
            if (keys.left) targetX -= 25 * delta;
            if (keys.right) targetX += 25 * delta;
            if (keys.up) targetY += 25 * delta;
            if (keys.down) targetY -= 25 * delta;
            
            targetX = Math.max(-8, Math.min(8, targetX));
            targetY = Math.max(-1.5, Math.min(3.5, targetY));

            const now = performance.now();
            checkPhaseLogic(now);
            
            // Boss Logic
            if (score >= nextBossScoreThreshold && !boss) {
                spawnBoss();
            }
            
            if (boss) {
                // Boss Move to Z position
                if (boss.position.z < -25) {
                    boss.position.z += 15 * delta;
                } else {
                    // Hover Pattern
                    boss.userData.movePhase += delta;
                    boss.position.x = Math.sin(boss.userData.movePhase * 0.5) * 4;
                    boss.position.y = Math.sin(boss.userData.movePhase * 1.2) * 1.0 + 1.0; // Higher up
                    
                    // Rotate Boss
                    boss.rotation.x += delta * 0.2;
                    boss.rotation.y += delta * 0.3;
                    
                    // Spawn Minions (Bullets)
                    if (now - boss.userData.lastSpawn > 1500) {
                        spawnEnemy(boss.position, true); // Spawn boss projectile
                        boss.userData.lastSpawn = now;
                    }
                }
            }
            
            // Power Up Timer
            if (playerState.activePowerUp !== 'NONE' && now > playerState.powerUpEndTime) {
                playerState.activePowerUp = 'NONE';
                document.getElementById('powerup-display').innerText = "";
            }
            
            // Shooting Logic
            let fireRate = 250;
            if (playerState.activePowerUp === 'RAPID') fireRate = 100;
            
            if (keys.fire && now - lastFireTime > fireRate) {
                if (playerState.activePowerUp === 'SPREAD') {
                    createLaser(0, 0);
                    createLaser(-0.5, 0.1); // Left angled
                    createLaser(0.5, -0.1); // Right angled
                } else {
                    createLaser(0, 0);
                }
                lastFireTime = now;
            }
            
            player.position.x += (targetX - player.position.x) * 0.1;
            player.position.y += (targetY - player.position.y) * 0.1;
            
            player.rotation.z = (player.position.x - targetX) * 0.1;
            player.rotation.x = (player.position.y - targetY) * 0.1; // Pitch tilt
            
            // Shield Pulse & Rotation
            if (shieldMesh.visible) {
                const pulse = 1.0 + Math.sin(now * 0.005) * 0.05;
                shieldMesh.scale.setScalar(pulse);
                
                // Rotate layers independently for RGB interference
                shieldMesh.children[0].rotation.x += delta * 0.5;
                shieldMesh.children[0].rotation.y += delta * 0.5;
                
                shieldMesh.children[1].rotation.x -= delta * 0.3;
                shieldMesh.children[1].rotation.y += delta * 0.8;
                
                shieldMesh.children[2].rotation.x += delta * 0.7;
                shieldMesh.children[2].rotation.y -= delta * 0.4;
            }
            
            // Camera Shake
            if (shakeIntensity > 0) {
                const shake = shakeIntensity;
                camera.position.x = (Math.random() - 0.5) * shake;
                camera.position.y = 1.0 + (Math.random() - 0.5) * shake;
                camera.position.z = 6 + (Math.random() - 0.5) * shake;
                shakeIntensity *= 0.9;
                if(shakeIntensity < 0.01) shakeIntensity = 0;
            } else {
                camera.position.set(0, 1.0, 6); 
            }

            if (rgbPass && rgbPass.uniforms['amount'].value > 0.002) {
                rgbPass.uniforms['amount'].value *= 0.9;
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.rotation.x += p.userData.rotSpeed.x;
                p.userData.life -= 2.0 * delta;
                p.material.opacity = p.userData.life;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            }

            // Lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                if (lasers[i].userData.velocity) {
                    // Use velocity for spread shot
                    lasers[i].position.x += lasers[i].userData.velocity.x * delta;
                    lasers[i].position.z += lasers[i].userData.velocity.z * delta;
                } else {
                    lasers[i].position.z -= 20 * delta;
                }
                
                if (lasers[i].position.z < -100) { scene.remove(lasers[i]); lasers.splice(i, 1); }
            }
            
            // Powerups Move
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                p.position.z += 10 * delta;
                
                if (p.userData.isRGB) {
                    // Rotate RGB layers
                    p.children[0].rotation.x += delta * 2;
                    p.children[1].rotation.y += delta * 2;
                    p.children[2].rotation.z += delta * 2;
                    
                    // Pulsate
                    const s = 1.0 + Math.sin(now * 0.005) * 0.2;
                    p.scale.setScalar(s);
                } else {
                    p.rotation.x += delta;
                    p.rotation.y += delta;
                }

                if (p.position.z > 6) { scene.remove(p); powerUps.splice(i, 1); }
            }
            
            const baseSpeed = 0.025 + (now - gameStartTime) / 120000 * 0.06;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const moveSpeed = baseSpeed * (enemies[i].userData.speedMult || 1.0);
                enemies[i].position.z += moveSpeed * delta * 60 * 20; 
                if (enemies[i].userData.rotSpeed) {
                    enemies[i].rotation.x += enemies[i].userData.rotSpeed.x;
                    enemies[i].rotation.y += enemies[i].userData.rotSpeed.y;
                }
                if (enemies[i].position.z > 6) {
                    scene.remove(enemies[i]); enemies.splice(i, 1);
                    missedEnemies++; AudioSys.playBreach(); 
                    shakeIntensity += 0.3;
                    if(rgbPass) rgbPass.uniforms['amount'].value = 0.05;
                    updateUI();
                    if (missedEnemies >= 3) gameOver("SECURITY BREACH");
                }
            }

            // Spawn Logic
            if (!boss) {
                if (now - lastEnemySpawnTime > Math.max(600, 2500 - (now - gameStartTime)/120000*1900)) spawnEnemy();
            }
            
            // Spawn Powerups (Rare)
            if (now - lastPowerUpSpawnTime > 15000) { // Every 15s check
                if (Math.random() > 0.3) spawnPowerUp(); // 70% chance
                else lastPowerUpSpawnTime = now; // Reset timer if missed to avoid spam checking
            }
            
            checkCollisions();
        }
        composer.render();
    }
    init();
</script>
</body>
</html>