<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Spectre Protocol</title>
    
    <!-- PWA / iOS Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0b0213">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Custom Icon (Spectre Eye) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512' style='background:%230b0213'%3E%3Cpath d='M256 32L32 480h448L256 32zm0 112l128 256H128L256 144z' fill='%23ff007f'/%3E%3Ccircle cx='256' cy='300' r='64' fill='%2300ffc8'/%3E%3Cpath d='M256 260a40 40 0 1 0 0 80 40 40 0 1 0 0-80z' fill='%230b0213'/%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512' style='background:%230b0213'%3E%3Cpath d='M256 32L32 480h448L256 32zm0 112l128 256H128L256 144z' fill='%23ff007f'/%3E%3Ccircle cx='256' cy='300' r='64' fill='%2300ffc8'/%3E%3Cpath d='M256 260a40 40 0 1 0 0 80 40 40 0 1 0 0-80z' fill='%230b0213'/%3E%3C/svg%3E">
    <link rel="manifest" href="manifest.json">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background-color: #050505; /* Darker Background */
            touch-action: none;
            -webkit-touch-callout: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #main-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            min-height: 80px;
            background: linear-gradient(to top, rgba(5, 5, 5, 0.95), rgba(5, 5, 5, 0.6));
            backdrop-filter: blur(4px);
            border-top: 2px solid #00ffc8; /* Cyan Border */
            z-index: 20;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            padding-bottom: env(safe-area-inset-bottom);
            box-shadow: 0 -5px 20px rgba(0, 255, 200, 0.1);
            pointer-events: none;
        }
        
        #ui-panel > * {
            pointer-events: auto;
        }

        #hud {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            left: 20px;
            color: #00ffc8;
            font-family: monospace;
            font-size: 1.2rem;
            z-index: 50;
            text-shadow: 0 0 5px #00ffc8;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-radius: 4px;
            min-width: 200px;
        }
        
        #boss-hud {
            display: none;
            margin-top: 10px;
            border-top: 1px solid #ff007f;
            padding-top: 5px;
        }
        
        #boss-health-bar-container {
            width: 100%;
            height: 10px;
            background: #330011;
            border: 1px solid #ff007f;
            margin-top: 5px;
        }
        
        #boss-health-bar {
            width: 100%;
            height: 100%;
            background: #ff007f;
            box-shadow: 0 0 10px #ff007f;
            transition: width 0.2s;
        }
        
        .breach-warning {
            color: #ff007f;
            font-weight: bold;
            animation: pulse-red 1s infinite;
        }
        
        .powerup-active {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            animation: pulse-gold 0.5s infinite alternate;
        }
        
        @keyframes pulse-gold {
            from { opacity: 0.8; }
            to { opacity: 1; text-shadow: 0 0 20px #ffd700; }
        }

        @keyframes pulse-red {
            0% { opacity: 0.7; text-shadow: 0 0 5px #ff007f; }
            50% { opacity: 1; text-shadow: 0 0 15px #ff007f; }
            100% { opacity: 0.7; text-shadow: 0 0 5px #ff007f; }
        }

        h1 {
            color: #00ffc8;
            text-shadow: 0 0 10px #00ffc8;
            font-size: 1.5rem;
            margin: 0;
            font-family: monospace;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: #00ffc8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            backdrop-filter: blur(5px);
            padding-bottom: 140px;
            box-sizing: border-box;
        }
        
        .glitch-text {
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: 4px;
            text-shadow: 2px 2px #00ffc8;
            animation: glitch-effect 0.2s infinite alternate-reverse;
            margin-bottom: 1rem;
        }
        
        @keyframes glitch-effect {
            0% { transform: translate(1px, 1px); text-shadow: 2px 2px #00ffc8; }
            25% { transform: translate(-1px, -1px); text-shadow: -2px 2px #ff007f; }
            50% { transform: translate(-1px, 1px); text-shadow: 2px -2px #00ffc8; }
            100% { transform: translate(1px, -1px); text-shadow: -2px -2px #ff007f; }
        }
        
        .neon-button {
            background: #0b0213;
            color: #00ffc8;
            padding: 1rem 2.5rem;
            border-radius: 4px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border: 2px solid #00ffc8;
            box-shadow: 0 0 10px #00ffc8, inset 0 0 10px #00ffc8;
            transition: all 0.2s;
            margin-top: 20px;
            font-family: monospace;
            letter-spacing: 2px;
        }
        
        .neon-button:hover {
            background: #00ffc8;
            color: #0b0213;
            box-shadow: 0 0 20px #00ffc8, inset 0 0 20px #00ffc8;
        }

        .control-btn {
            background: transparent;
            border: 1px solid #00ffc8;
            color: #00ffc8;
            padding: 0.4rem 1rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: 0.2s;
            font-family: monospace;
            margin-left: 10px;
        }
        
        .control-btn:hover {
            background: #00ffc8;
            color: #000;
        }
        
        .leaderboard {
            width: 90%;
            max-width: 450px;
            margin-top: 20px;
            border: 2px solid #00ffc8;
            box-shadow: 0 0 15px #00ffc8;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffc8;
            max-height: 30vh;
            overflow-y: auto;
        }

        .leaderboard h3 {
            background: #00ffc8;
            color: #0b0213;
            padding: 8px;
            margin: 0;
            font-size: 1.1rem;
            text-shadow: none;
            position: sticky;
            top: 0;
        }
        
        .leaderboard table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .leaderboard th, .leaderboard td {
            padding: 6px 10px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 255, 200, 0.2);
        }
        
        .leaderboard tr:nth-child(even) {
            background: rgba(0, 255, 200, 0.05);
        }

        .leaderboard tr:hover {
            background: rgba(0, 255, 200, 0.1);
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 80px;
            left: 0;
            width: 100%;
            height: 140px;
            z-index: 60;
            padding: 0 20px;
            box-sizing: border-box;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            padding-bottom: env(safe-area-inset-bottom);
        }

        #joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(0, 255, 200, 0.1);
            border: 2px solid rgba(0, 255, 200, 0.4);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            backdrop-filter: blur(2px);
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 200, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #00ffc8;
        }

        #fire-btn-mobile {
            width: 100px;
            height: 100px;
            background: rgba(0, 255, 200, 0.2);
            border: 3px solid #00ffc8;
            border-radius: 50%;
            color: #00ffc8;
            font-family: monospace;
            font-weight: bold;
            font-size: 1.2rem;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(0, 255, 200, 0.4);
            backdrop-filter: blur(2px);
            user-select: none;
            -webkit-user-select: none;
        }
        
        #fire-btn-mobile:active {
            background: rgba(0, 255, 200, 0.6);
            color: #fff;
            box-shadow: 0 0 30px #00ffc8;
        }
        
        /* iOS Install Guide */
        #ios-install-guide {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(11, 2, 19, 0.95);
            border-top: 2px solid #00ffc8;
            padding: 20px;
            padding-bottom: 50px;
            z-index: 200;
            flex-direction: column;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            #ui-panel {
                flex-direction: column;
                padding: 0.5rem;
                gap: 0.25rem;
                min-height: 60px;
            }
            .glitch-text { font-size: 2rem; }
            .leaderboard { width: 95%; }
            #instructions .text-cyan-300 { display: none; }
            h1 { font-size: 1.2rem; }
            #hud { font-size: 1rem; top: 10px; left: 10px; min-width: 150px; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
            }
        }
    </script>
</head>
<body>

<div id="main-container">
    <div id="game-container">
        <div id="hud">
            <div>SCORE: <span id="score-display">0</span></div>
            <div class="mt-2 text-red-400">BREACHES: <span id="missed-display">0</span>/3</div>
            <div id="powerup-display" class="text-sm mt-2 font-bold"></div>
            <div id="wave-display" class="text-xs mt-1 text-pink-500 opacity-80">PHASE: INITIALIZING</div>
            
            <!-- Boss HUD -->
            <div id="boss-hud">
                <div id="boss-name" class="text-[#ff2a00] font-bold text-sm tracking-widest">WARNING: BOSS DETECTED</div>
                <div id="boss-health-bar-container">
                    <div id="boss-health-bar"></div>
                </div>
            </div>
        </div>
        
        <div id="mobile-controls">
            <div id="joystick-container">
                <div id="joystick-knob"></div>
            </div>
            <button id="fire-btn-mobile">FIRE</button>
        </div>

        <div id="overlay-screen">
            <p class="glitch-text" id="overlay-title">SPECTRE PROTOCOL</p>
            
            <div id="form-container" class="hidden w-full max-w-sm flex flex-col items-center mt-4 mb-4">
                 <p class="text-[#00ffc8] font-mono text-sm mb-2 tracking-widest animate-pulse">NEW HIGH SCORE DETECTED</p>
                 <div class="flex gap-2 w-full justify-center">
                    <input id="agent-name-input" type="text" maxlength="12" 
                           class="bg-gray-900/80 border-2 border-[#00ffc8] text-[#00ffc8] px-3 py-2 font-mono text-center uppercase focus:outline-none focus:border-[#00ffc8] focus:shadow-[0_0_10px_#00ffc8] transition-all w-48 placeholder-cyan-900" 
                           placeholder="AGENT_ID">
                    <button id="submit-score-btn" class="bg-[#00ffc8]/20 border-2 border-[#00ffc8] text-[#00ffc8] px-4 py-2 font-mono hover:bg-[#00ffc8] hover:text-black transition-all font-bold">
                        UPLOAD
                    </button>
                 </div>
            </div>

            <div id="leaderboard-display" class="leaderboard">
                <h3>TOP 10 INTERCEPTORS</h3>
                <table>
                    <thead><tr><th>Rank</th><th>Agent</th><th>Score</th></tr></thead>
                    <tbody id="leaderboard-body">
                        <tr><td colspan="3" class="text-center text-xs text-cyan-400">Loading Neural Link...</td></tr>
                    </tbody>
                </table>
            </div>
            <div id="instructions" class="text-center mt-6">
                <p class="text-white font-mono text-sm max-w-md p-2 mx-auto">
                    MISSION: INTERCEPT INCOMING DATA BLOCKS.
                </p>
                <p class="text-pink-500 font-mono text-xs mb-4">
                    WARNING: ALLOWING 3 ENEMIES TO PASS RESULTS IN SYSTEM FAILURE.
                </p>
                <div class="text-cyan-300 text-xs font-mono mb-6">
                    MOVE: WASD / ARROWS | FIRE: HOLD SPACE / CLICK
                </div>
            </div>
            <button id="start-btn" class="neon-button">INITIATE PROTOCOL</button>
            
            <!-- iOS Install Button (Hidden by default) -->
            <button id="ios-install-btn" class="mt-4 border border-[#00ffc8] text-[#00ffc8] bg-transparent px-4 py-2 font-mono text-xs rounded hover:bg-[#00ffc8] hover:text-black transition-colors hidden">
                INSTALL APP (iOS)
            </button>
        </div>
    </div>
    
    <!-- iOS Install Overlay Guide -->
    <div id="ios-install-guide">
        <p class="text-[#00ffc8] font-mono text-lg mb-2 font-bold">INSTALL PROTOCOL</p>
        <p class="text-white font-mono text-sm mb-4 leading-relaxed text-left pl-8">
            1. Tap <span class="font-bold text-lg">•••</span> (Three Dots).<br>
            2. Tap <span class="text-blue-400 font-bold text-xl mx-1">⎋</span> Share.<br>
            3. Tap <span class="font-bold">More...</span><br>
            4. Select <span class="text-white font-bold border border-gray-600 px-1 rounded bg-gray-800 text-xs">Add to Home Screen</span>.
        </p>
        <button id="close-guide-btn" class="text-pink-500 font-mono text-sm border border-pink-500 px-4 py-1 rounded hover:bg-pink-500 hover:text-white transition-colors">
            CLOSE
        </button>
        <div class="absolute bottom-2 left-1/2 transform -translate-x-1/2 text-[#00ffc8] animate-bounce text-2xl">↓</div>
    </div>
    
    <div id="ui-panel">
        <div class="flex flex-col items-start">
            <h1>SPECTRE PROTOCOL</h1>
            <p id="sys-version" class="text-xs text-cyan-600 font-mono">SYS.VER.10.0.1 // STEALTH OPS</p>
        </div>
        <div class="text-center hidden md:block">
            <div class="text-xs text-cyan-500 font-mono animate-pulse">DATABASE LINK ESTABLISHED</div>
        </div>
        <div class="control-group flex items-center">
            <button id="mute-btn" class="control-btn">MUTE AUDIO</button>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { CopyShader } from 'three/addons/shaders/CopyShader.js';
    import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';

    import { initializeApp } from 'firebase/app';
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
    import { getFirestore, collection, query, orderBy, limit, onSnapshot, addDoc, serverTimestamp, setLogLevel } from 'firebase/firestore';

    // --- CONFIGURATION ---
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyDV7eXu5ERIic4pdE99qfoiH-_-uELJEgw",
      authDomain: "spectreprotocol-c21c5.firebaseapp.com",
      projectId: "spectreprotocol-c21c5",
      storageBucket: "spectreprotocol-c21c5.firebasestorage.app",
      messagingSenderId: "964619451248",
      appId: "1:964619451248:web:0adbc90162d36db6412db5",
      measurementId: "G-WFK1184JWY"
    };
    
    const FirebaseState = {
        db: null,
        auth: null,
        userId: null
    };

    const injectedConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
    let activeConfig = {};
    if (injectedConfig && injectedConfig !== '{}') {
        activeConfig = JSON.parse(injectedConfig);
    } else if (Object.keys(FIREBASE_CONFIG).length > 0) {
        activeConfig = FIREBASE_CONFIG;
    }

    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    if (Object.keys(activeConfig).length > 0 && activeConfig.apiKey) {
        try {
            const app = initializeApp(activeConfig);
            FirebaseState.db = getFirestore(app);
            FirebaseState.auth = getAuth(app);
            setLogLevel('silent'); // Suppress internal warnings
        } catch (e) {
            console.error("Firebase Init Error:", e);
        }
    }

    async function initializeFirebase() {
        const auth = FirebaseState.auth;
        if (!auth) {
            setupLeaderboardListener();
            return;
        }
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            FirebaseState.userId = crypto.randomUUID();
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                FirebaseState.userId = user.uid;
                setupLeaderboardListener();
            } else {
                FirebaseState.userId = crypto.randomUUID();
                setupLeaderboardListener();
            }
        });
    }

    function getScoresCollectionRef() {
        return collection(FirebaseState.db, `artifacts/${appId}/public/data/scores`);
    }

    function setupLeaderboardListener() {
        // Fallback function to use LocalStorage if Firebase fails
        const useLocal = () => {
            const localScores = JSON.parse(localStorage.getItem('spectre_local_leaderboard') || '[]');
            if (localScores.length === 0) {
                 localScores.push(
                     {name: 'SPECTRE', score: 5000},
                     {name: 'GHOST', score: 3500},
                     {name: 'PHANTOM', score: 2000}
                 );
                 localStorage.setItem('spectre_local_leaderboard', JSON.stringify(localScores));
            }
            renderLeaderboard(localScores.sort((a, b) => b.score - a.score));
            document.getElementById('sys-version').innerText = "SYS.VER.10.0.1 // LOCAL STORAGE";
        };

        if (!FirebaseState.db) {
            useLocal();
            return;
        }
        
        document.getElementById('sys-version').innerText = "SYS.VER.10.0.1 // CLOUD SYNC";
        const scoresQuery = query(getScoresCollectionRef(), orderBy('score', 'desc'), limit(10));
        
        onSnapshot(scoresQuery, (snapshot) => {
            renderLeaderboard(snapshot.docs.map(doc => doc.data()));
        }, (error) => {
            console.warn("Firebase connection unavailable, falling back to local storage.");
            useLocal();
        });
    }

    function renderLeaderboard(scores) {
        const body = document.getElementById('leaderboard-body');
        body.innerHTML = '';
        if (scores.length === 0) {
            body.innerHTML = `<tr><td colspan="3" class="text-center text-xs text-cyan-400">No scores yet.</td></tr>`;
            return;
        }
        scores.forEach((s, index) => {
            const row = body.insertRow();
            row.insertCell(0).innerText = index + 1;
            row.insertCell(1).innerText = s.name ? s.name.substring(0, 12) : 'UNKNOWN';
            row.insertCell(2).innerText = s.score;
        });
    }

    function submitScore() {
        const input = document.getElementById('agent-name-input');
        const name = input.value.trim().toUpperCase() || 'ANONYMOUS';
        const finalScore = score;

        if (FirebaseState.db) {
            addDoc(getScoresCollectionRef(), {
                name: name,
                score: finalScore,
                timestamp: serverTimestamp(),
                userId: FirebaseState.userId,
            }).then(() => {
                 localStorage.setItem('spectre_agent_name', name);
                 resetOverlayToStart();
            }).catch(e => {
                saveLocalScore(name, finalScore);
                resetOverlayToStart();
            });
        } else {
            saveLocalScore(name, finalScore);
            resetOverlayToStart();
        }
    }
    
    function saveLocalScore(name, finalScore) {
        const localScores = JSON.parse(localStorage.getItem('spectre_local_leaderboard') || '[]');
        localScores.push({ name: name, score: finalScore, timestamp: Date.now() });
        localScores.sort((a, b) => b.score - a.score);
        const top10 = localScores.slice(0, 10);
        localStorage.setItem('spectre_local_leaderboard', JSON.stringify(top10));
        renderLeaderboard(top10);
        localStorage.setItem('spectre_agent_name', name);
    }
    
    function resetOverlayToStart() {
        document.getElementById('form-container').classList.add('hidden');
        const btn = document.getElementById('start-btn');
        btn.innerText = "RE-INITIALIZE";
        btn.style.display = 'block';
    }

    // --- AUDIO ENGINE ---
    const AudioSys = {
        ctx: null, isMuted: false, isPlaying: false,
        nextNoteTime: 0, tempo: 128, lookahead: 25.0, scheduleAheadTime: 0.1, timerID: null, measure: 0, beat: 0,
        
        init: function() {
            if (!this.ctx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            }
        },
        
        unlock: function() {
            if (!this.ctx) this.init();
            const buffer = this.ctx.createBuffer(1, 1, 22050);
            const source = this.ctx.createBufferSource();
            source.buffer = buffer;
            source.connect(this.ctx.destination);
            source.start(0);
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },

        toggleMute: function() {
            this.isMuted = !this.isMuted;
            if (this.isMuted) { if(this.ctx) this.ctx.suspend(); } 
            else { if(this.ctx) this.ctx.resume(); }
            return this.isMuted;
        },
        
        playTone: function(freq, type, len, time, vol=0.1) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(vol, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + len);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + len);
        },

        playNoise: function(len, filterFreq, time) {
            if (this.isMuted || !this.ctx) return;
            const bufferSize = this.ctx.sampleRate * len;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = filterFreq;
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + len);
            noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            noise.start(time);
        },
        
        playKick: function(time) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.5);
        },
        
        playSnare: function(time) { this.playNoise(0.1, 1000, time); },
        playHiHat: function(time, open = false) { this.playNoise(open ? 0.1 : 0.05, 8000, time); },

        playBass: function(time, freq, intensity = 0) {
             if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, time);
            filter.type = 'lowpass';
            const baseFreq = 200 + (intensity * 2000);
            filter.frequency.setValueAtTime(baseFreq, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + 0.2);
            gain.gain.setValueAtTime(0.15, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
            osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.3);
        },

        playLead: function(time, freq) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(freq, time);
            osc.frequency.linearRampToValueAtTime(freq + 5, time + 0.1);
            gain.gain.setValueAtTime(0.05, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.3);
        },

        playRiser: function(time, pitch) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(pitch, time);
            osc.frequency.linearRampToValueAtTime(pitch + 100, time + 0.1);
            gain.gain.setValueAtTime(0.05, time);
            gain.gain.linearRampToValueAtTime(0.01, time + 0.1);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.1);
        },
        
        scheduleNote: function(beatNumber, time) {
            const gameTime = (performance.now() - gameStartTime) / 1000;
            const phaseInterval = 30; 
            const timeInPhase = gameTime % phaseInterval;
            const isBuildUp = (timeInPhase > 26 && gameTime > 10);
            
            if (isBuildUp) {
                let playRoll = false;
                if (timeInPhase < 28 && beatNumber % 4 === 0) playRoll = true;
                else if (timeInPhase >= 28 && timeInPhase < 29 && beatNumber % 2 === 0) playRoll = true;
                else if (timeInPhase >= 29) playRoll = true;
                
                if (playRoll) {
                    this.playSnare(time);
                    this.playRiser(time, 200 + (timeInPhase - 26) * 200);
                }
                return; 
            }

            if (beatNumber % 4 === 0) this.playKick(time);
            if (beatNumber === 4 || beatNumber === 12) this.playSnare(time);
            
            if (gameTime > 10) {
                if (gameTime > 60) {
                     this.playHiHat(time, beatNumber % 4 === 2);
                     if (beatNumber % 2 !== 0) this.playHiHat(time, false);
                } else if (gameTime > 30) {
                    this.playHiHat(time, beatNumber % 4 === 2);
                } else if (beatNumber % 2 === 0) {
                    this.playHiHat(time);
                }
            }
            
            if (gameTime > 5) {
                 const bassRoot = [55, 55, 65.4, 43.6][Math.floor((this.measure % 4))]; 
                 const bassIntensity = Math.min(1, gameTime / 90);
                 if (beatNumber === 0 || beatNumber === 3 || beatNumber === 7 || beatNumber === 10) {
                     this.playBass(time, bassRoot, bassIntensity);
                 }
            }
            
            if (gameTime > 30 && beatNumber % 2 === 0) {
                const arpNotes = [440, 523, 659, 880];
                if (gameTime > 60 || Math.random() > 0.5) {
                    this.playLead(time, arpNotes[Math.floor(Math.random()*arpNotes.length)]);
                }
            }
        },
        
        scheduler: function() {
            while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.beat, this.nextNoteTime);
                const secondsPerBeat = 60.0 / this.tempo / 4;
                this.nextNoteTime += secondsPerBeat;
                this.beat++;
                if (this.beat === 16) { this.beat = 0; this.measure++; }
            }
            this.timerID = window.setTimeout(this.scheduler.bind(this), this.lookahead);
        },
        start: function() {
            if (this.isPlaying) return;
            this.isPlaying = true; this.beat = 0; this.measure = 0;
            this.tempo = 128;
            this.nextNoteTime = this.ctx.currentTime + 0.1;
            this.scheduler();
        },
        stop: function() {
            this.isPlaying = false; window.clearTimeout(this.timerID);
        },
        
        playLaser: function() { 
            if (this.isMuted || !this.ctx) return;
            const time = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(350, time);
            osc.frequency.exponentialRampToValueAtTime(60, time + 0.15);
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.15);
        },

        playExplosion: function() {
             if (this.isMuted || !this.ctx) return;
             for(let i=0; i<3; i++) {
                 this.playBass(this.ctx.currentTime, 30 + Math.random() * 40, 1.0); 
             }
        },
        playBreach: function() {
            if (this.isMuted || !this.ctx) return;
            this.playTone(150, 'sawtooth', 0.5, this.ctx.currentTime, 0.5);
        },
        playPowerUp: function() {
             if (this.isMuted || !this.ctx) return;
             this.playTone(880, 'sine', 0.1, this.ctx.currentTime, 0.2);
             this.playTone(1100, 'sine', 0.2, this.ctx.currentTime + 0.1, 0.2);
        },
        playShieldBreak: function() {
             if (this.isMuted || !this.ctx) return;
             this.playNoise(0.4, 200, this.ctx.currentTime);
        },
        playBossSpawn: function() {
            if (this.isMuted || !this.ctx) return;
            this.playTone(100, 'sawtooth', 1.5, this.ctx.currentTime, 1.0);
            this.playTone(80, 'sawtooth', 1.5, this.ctx.currentTime, 1.0);
        }
    };

    let scene, camera, renderer, composer, rgbPass;
    let player, hullMesh, frameMesh, groundMesh1, groundMesh2;
    let boss = null;
    let nextBossScoreThreshold = 5000;
    
    const lasers = [];
    const enemies = [];
    const particles = [];
    const powerUps = [];
    
    const keys = { left: false, right: false, up: false, down: false, fire: false };
    let isFiring = false;
    let lastFireTime = 0;
    
    // Game Logic
    let score = 0, missedEnemies = 0, isGameOver = false, isGameRunning = false, gameStartTime = 0;
    let currentPhase = 0; 
    let spawnInterval = 2500, lastEnemySpawnTime = 0, lastPowerUpSpawnTime = 0;
    let targetX = 0;
    let targetY = -1.0;
    let shakeIntensity = 0;
    
    // Player Health System
    let playerHP = 3;
    let playerInvulnerableUntil = 0;
    let baseShipScale = 1.0;
    
    // Death Sequence State
    let isDying = false;
    let deathStartTime = 0;
    
    // Player State
    const playerState = {
        shield: false,
        activePowerUp: 'NONE',
        powerUpEndTime: 0
    };
    
    // STEALTH PALETTE
    const COLORS = { 
        cyan: 0x00ffc8, 
        darkCyan: 0x008866,
        pink: 0xff007f, 
        dark: 0x050505, 
        neonGreen: 0x00ff41, 
        neonBlue: 0x0088ff,
        neonMagenta: 0xff00ff,
        gold: 0xffd700,
        white: 0xffffff,
        neonYellow: 0xffff00,
        hullGrey: 0x222222
    };
    const GROUND_SIZE = 200;
    
    const ENEMY_CONFIGS = [
        { name: 'STANDARD', color: 0xff007f, speed: 1.0, rot: {x: 0.02, y: 0.02}, score: 100 },
        { name: 'FAST', color: 0x00ffc8, speed: 1.5, rot: {x: 0.0, y: 0.1}, score: 150 },
        { name: 'HEAVY', color: 0xff2a00, speed: 0.7, rot: {x: 0.005, y: 0.005}, score: 200 }
    ];
    
    const BOSS_CONFIGS = [
        { name: "THE MONOLITH", type: 'CUBE', color: 0xff007f, hp: 30, score: 1000 },
        { name: "THE PRISM", type: 'TETRA', color: 0x00ffc8, hp: 20, score: 2000 },
        { name: "THE HIVE", type: 'ICO', color: 0xffd700, hp: 50, score: 3000 }
    ];
    
    const POWERUP_TYPES = [
        { name: 'RAPID', color: COLORS.gold, label: "RAPID FIRE" },
        { name: 'SPREAD', color: COLORS.neonBlue, label: "SPREAD SHOT" },
        { name: 'SHIELD', color: COLORS.white, label: "ARMOR PLATING" }
    ];

    function init() {
        initializeFirebase();
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.dark);
        scene.fog = new THREE.FogExp2(COLORS.dark, 0.02); 

        camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.0, 6); 
        camera.rotation.x = -0.1;

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(COLORS.cyan, 0.3);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(COLORS.cyan, 0.8);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        createGround();
        createPlayerShip();
        createStarfield();
        setupPostProcessing(container.clientWidth, container.clientHeight);
        setupMobileControls();
        checkOrientation();
        setupIOSInstall();

        window.addEventListener('resize', onWindowResize);
        
        container.addEventListener('mousemove', (e) => {
             if(e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
             const rect = renderer.domElement.getBoundingClientRect();
             targetX = ((e.clientX - rect.left) / rect.width * 2 - 1) * 8;
             targetY = -((e.clientY - rect.top) / rect.height * 2 - 1) * 4 + 1;
             targetY = Math.max(-1.5, Math.min(3.5, targetY));
        });
        container.addEventListener('mousedown', () => { keys.fire = true; });
        container.addEventListener('mouseup', () => { keys.fire = false; });
        
        document.addEventListener('touchstart', () => {
             if(AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.unlock();
        }, {once: true});

        window.addEventListener('keydown', (e) => {
            if(!isGameRunning || isDying) return;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') { keys.left = true; }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') { keys.right = true; }
            if (e.code === 'ArrowUp' || e.code === 'KeyW') { keys.up = true; }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') { keys.down = true; }
            if (e.code === 'Space') { keys.fire = true; e.preventDefault(); }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
            if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
            if (e.code === 'Space') keys.fire = false;
        });

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('submit-score-btn').addEventListener('click', submitScore);
        
        document.getElementById('mute-btn').addEventListener('click', (e) => {
            e.target.innerText = AudioSys.toggleMute() ? "UNMUTE AUDIO" : "MUTE AUDIO";
        });
        
        const savedName = localStorage.getItem('spectre_agent_name');
        if(savedName) document.getElementById('agent-name-input').value = savedName;
        
        setTimeout(() => {
            if (!FirebaseState.db) {
                setupLeaderboardListener();
            }
        }, 1000);

        animate(0);
    }
    
    function setupIOSInstall() {
        // Detect iOS and NOT standalone
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
        
        if (isIOS && !isStandalone) {
            const btn = document.getElementById('ios-install-btn');
            const guide = document.getElementById('ios-install-guide');
            const closeBtn = document.getElementById('close-guide-btn');
            
            btn.classList.remove('hidden');
            
            btn.addEventListener('click', () => {
                guide.style.display = 'flex';
            });
            
            closeBtn.addEventListener('click', () => {
                guide.style.display = 'none';
            });
        }
    }
    
    function checkOrientation() {
        if(!player) return;
        // Reduce ship size in Portrait mode (Phones) to make dodging easier
        const isPortrait = window.innerHeight > window.innerWidth;
        baseShipScale = isPortrait ? 0.5 : 1.0;
        if(!isDying) player.scale.setScalar(baseShipScale);
    }
    
    function setupMobileControls() {
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isTouch) {
            const controls = document.getElementById('mobile-controls');
            controls.style.display = 'flex';
            const desktopInstr = document.querySelector('#instructions .text-cyan-300');
            if(desktopInstr) desktopInstr.style.display = 'none';
            
            const joystickContainer = document.getElementById('joystick-container');
            const joystickKnob = document.getElementById('joystick-knob');
            const fireBtn = document.getElementById('fire-btn-mobile');
            
            let touchId = null;
            const maxRadius = 35;
            
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if(touchId !== null) return;
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                updateJoystick(touch);
            });
            
            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        updateJoystick(e.changedTouches[i]);
                        break;
                    }
                }
            });
            
            const resetJoystick = (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        touchId = null;
                        joystickKnob.style.transform = `translate(-50%, -50%)`;
                        break;
                    }
                }
            };
            
            joystickContainer.addEventListener('touchend', resetJoystick);
            joystickContainer.addEventListener('touchcancel', resetJoystick);
            
            function updateJoystick(touch) {
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
                const angle = Math.atan2(dy, dx);
                
                const knobX = Math.cos(angle) * distance;
                const knobY = Math.sin(angle) * distance;
                
                joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
                
                const normX = knobX / maxRadius;
                const normY = knobY / maxRadius; 
                
                targetX = normX * 8.0;
                targetY = 1.0 + (-normY * 2.5);
                targetX = Math.max(-8, Math.min(8, targetX));
                targetY = Math.max(-1.5, Math.min(3.5, targetY));
            }
            
            fireBtn.addEventListener('touchstart', (e) => {
                 e.preventDefault();
                 keys.fire = true;
                 fireBtn.style.background = "rgba(0, 255, 200, 0.6)";
            });
            
            fireBtn.addEventListener('touchend', (e) => {
                 e.preventDefault();
                 keys.fire = false;
                 fireBtn.style.background = "rgba(0, 255, 200, 0.2)";
            });
        }
    }

    function setupPostProcessing(w, h) {
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(w, h), 0.75, 0.5, 0.2));
        rgbPass = new ShaderPass(RGBShiftShader);
        rgbPass.uniforms['amount'].value = 0.0015; 
        composer.addPass(rgbPass);
        composer.addPass(new ShaderPass(CopyShader));
    }

    function createGround() {
        const width = 150;
        const length = GROUND_SIZE;
        const segmentsW = 50;
        const segmentsH = 50;
        const geo = new THREE.PlaneGeometry(width, length, segmentsW, segmentsH);
        
        const posAttribute = geo.attributes.position;
        const vertex = new THREE.Vector3();
        
        for (let i = 0; i < posAttribute.count; i++) {
            vertex.fromBufferAttribute(posAttribute, i);
            const distFromCenter = Math.abs(vertex.x);
            const safeZone = 15; 
            
            if (distFromCenter > safeZone) {
                const rise = Math.pow((distFromCenter - safeZone) / 4, 2.5);
                const noise = Math.random() * 2.5;
                vertex.z += rise + noise;
            }
            posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        geo.computeVertexNormals();

        const mat = new THREE.MeshBasicMaterial({ 
            color: COLORS.neonGreen, 
            wireframe: true, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3
        });

        groundMesh1 = new THREE.Mesh(geo, mat);
        groundMesh1.rotation.x = -Math.PI / 2;
        groundMesh1.position.set(0, -2, -GROUND_SIZE/2 + 6); 
        scene.add(groundMesh1);

        groundMesh2 = new THREE.Mesh(geo, mat);
        groundMesh2.rotation.x = -Math.PI / 2;
        groundMesh2.position.set(0, -2, -GROUND_SIZE/2 + 6 - GROUND_SIZE); 
        scene.add(groundMesh2);
    }

    function updateGround(delta) {
        const speed = 20 * delta;
        groundMesh1.position.z += speed;
        groundMesh2.position.z += speed;

        if (groundMesh1.position.z > 6 + GROUND_SIZE/2) groundMesh1.position.z -= GROUND_SIZE * 2;
        if (groundMesh2.position.z > 6 + GROUND_SIZE/2) groundMesh2.position.z -= GROUND_SIZE * 2;
    }
    
    function setPhase(p) {
        currentPhase = p;
        const hud = document.getElementById('wave-display');
        
        if (p === 1) {
            hud.innerText = "PHASE: PROTOCOL START";
            hud.className = "text-xs mt-1 text-[#00ff41] opacity-80";
            groundMesh1.material.color.setHex(COLORS.neonGreen);
            AudioSys.tempo = 128;
        } else if (p === 2) {
            hud.innerText = "PHASE: HARDLINE";
            hud.className = "text-xs mt-1 text-[#00ffff] opacity-100 font-bold";
            groundMesh1.material.color.setHex(COLORS.cyan);
            AudioSys.tempo = 138;
            composer.passes[1].strength = 3.0; 
            setTimeout(() => { composer.passes[1].strength = 0.75; }, 500);
        } else if (p === 3) {
            hud.innerText = "PHASE: SYSTEM OVERDRIVE";
            hud.className = "text-xs mt-1 text-[#ff00ff] opacity-100 font-bold animate-pulse";
            groundMesh1.material.color.setHex(COLORS.neonMagenta);
            AudioSys.tempo = 150;
            composer.passes[1].strength = 4.0;
            setTimeout(() => { composer.passes[1].strength = 0.75; }, 500);
        }
    }
    
    function checkPhaseLogic(now) {
        const time = (now - gameStartTime) / 1000;
        if (time < 30) { if (currentPhase !== 1) setPhase(1); } 
        else if (time < 60) { if (currentPhase !== 2) setPhase(2); } 
        else { if (currentPhase !== 3) setPhase(3); }
    }

    function createStarfield() {
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<2000; i++) pos.push((Math.random()-0.5)*200, (Math.random()-0.5)*100, (Math.random()-0.5)*200);
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({size: 0.1, color: 0xffffff});
        scene.add(new THREE.Points(geo, mat));
    }

    function createPlayerShip() {
        const group = new THREE.Group();
        
        // Define Jagged Stealth Fighter Geometry using BufferGeometry
        const shapeGeo = new THREE.BufferGeometry();
        
        // Vertices (X, Y, Z)
        // 0: Nose Tip (0, 0, -1.5)
        // 1: Cockpit Top (0, 0.5, 0.5)
        // 2: Wing Left Tip (-1.8, -0.2, 1.2)
        // 3: Wing Right Tip (1.8, -0.2, 1.2)
        // 4: Rear Center (0, 0, 1.5)
        // 5: Bottom Center (0, -0.3, 0.5)
        
        const vertices = new Float32Array([
             // Top Left Face
             0, 0, -1.5, -1.8, -0.2, 1.2, 0, 0.5, 0.5,
             // Top Right Face
             0, 0, -1.5, 0, 0.5, 0.5, 1.8, -0.2, 1.2,
             // Rear Left Face
             -1.8, -0.2, 1.2, 0, 0, 1.5, 0, 0.5, 0.5,
             // Rear Right Face
             1.8, -0.2, 1.2, 0, 0.5, 0.5, 0, 0, 1.5,
             // Bottom Left Face
             0, 0, -1.5, 0, -0.3, 0.5, -1.8, -0.2, 1.2,
             // Bottom Right Face
             0, 0, -1.5, 1.8, -0.2, 1.2, 0, -0.3, 0.5,
             // Bottom Rear Left
             -1.8, -0.2, 1.2, 0, -0.3, 0.5, 0, 0, 1.5,
             // Bottom Rear Right
             1.8, -0.2, 1.2, 0, 0, 1.5, 0, -0.3, 0.5
        ]);
        
        shapeGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        shapeGeo.computeVertexNormals();
        
        // 1. Wireframe Mesh (Always Visible)
        // CHANGED: Color set to Pink as requested
        const frameMat = new THREE.MeshBasicMaterial({ color: COLORS.pink, wireframe: true });
        frameMesh = new THREE.Mesh(shapeGeo, frameMat);
        group.add(frameMesh);
        
        // 2. Hull Mesh (Visible only with Armor/Shield)
        const hullMat = new THREE.MeshBasicMaterial({ 
            color: COLORS.hullGrey, 
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: 1, // Push behind wireframe
            polygonOffsetUnits: 1
        });
        hullMesh = new THREE.Mesh(shapeGeo, hullMat);
        hullMesh.visible = false; // Start transparent/wireframe only
        group.add(hullMesh);
        
        // 3. Engines
        const engineGeo = new THREE.CylinderGeometry(0.1, 0.2, 0.8, 5); // Pentagonal Engine
        const engineMat = new THREE.MeshBasicMaterial({ color: COLORS.darkCyan, wireframe: true });
        
        const eL = new THREE.Mesh(engineGeo, engineMat);
        eL.rotation.x = -Math.PI/2;
        eL.position.set(-0.8, 0, 1.0);
        group.add(eL);
        
        const eR = new THREE.Mesh(engineGeo, engineMat);
        eR.rotation.x = -Math.PI/2;
        eR.position.set(0.8, 0, 1.0);
        group.add(eR);
        
        // Engine Glow
        const glowGeo = new THREE.CircleGeometry(0.15, 8);
        const glowMat = new THREE.MeshBasicMaterial({ color: COLORS.neonGreen });
        
        const gL = new THREE.Mesh(glowGeo, glowMat);
        gL.rotation.x = Math.PI/2;
        gL.position.set(0, -0.41, 0);
        eL.add(gL);
        
        const gR = new THREE.Mesh(glowGeo, glowMat);
        gR.rotation.x = Math.PI/2;
        gR.position.set(0, -0.41, 0);
        eR.add(gR);

        player = group;
        player.position.set(0, -1.0, 0);
        scene.add(player);
    }

    function createBossMesh(config) {
        const group = new THREE.Group();
        let mainMesh;
        
        if (config.type === 'CUBE') {
            const geo = new THREE.BoxGeometry(4, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: config.color, wireframe: true });
            mainMesh = new THREE.Mesh(geo, mat);
            const core = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), new THREE.MeshBasicMaterial({color: 0xffffff}));
            group.add(core);
        } else if (config.type === 'TETRA') {
            const geo = new THREE.TetrahedronGeometry(3.5, 0);
            const mat = new THREE.MeshBasicMaterial({ color: config.color, wireframe: true });
            mainMesh = new THREE.Mesh(geo, mat);
            const rings = new THREE.Mesh(new THREE.TorusGeometry(3, 0.1, 8, 50), new THREE.MeshBasicMaterial({color: 0xffffff}));
            rings.rotation.x = Math.PI/2;
            group.add(rings);
        } else {
            const geo = new THREE.IcosahedronGeometry(3, 1);
            const mat = new THREE.MeshBasicMaterial({ color: config.color, wireframe: true });
            mainMesh = new THREE.Mesh(geo, mat);
            for(let i=0; i<6; i++) {
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2, 4), new THREE.MeshBasicMaterial({color: config.color}));
                spike.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);
                spike.lookAt(0,0,0);
                group.add(spike);
            }
        }
        group.add(mainMesh);
        return group;
    }

    function spawnBoss() {
        AudioSys.playBossSpawn();
        const config = BOSS_CONFIGS[Math.floor(Math.random() * BOSS_CONFIGS.length)];
        
        const mesh = createBossMesh(config);
        mesh.position.set(0, 0, -100); 
        
        mesh.userData = {
            isBoss: true,
            hp: config.hp,
            maxHp: config.hp,
            score: config.score,
            name: config.name,
            movePhase: 0,
            lastSpawn: 0
        };
        
        boss = mesh;
        scene.add(boss);
        mesh.updateMatrixWorld();
        document.getElementById('boss-hud').style.display = 'block';
        document.getElementById('boss-name').innerText = `WARNING: ${config.name} DETECTED`;
        document.getElementById('boss-health-bar').style.width = '100%';
        nextBossScoreThreshold += 5000;
    }
    
    function destroyBoss() {
        AudioSys.playExplosion();
        for(let i=0; i<5; i++) spawnParticles(boss.position, boss.children[0].material.color);
        shakeIntensity += 2.0;
        score += boss.userData.score;
        scene.remove(boss);
        boss = null;
        document.getElementById('boss-hud').style.display = 'none';
        updateUI();
    }

    function createLaser(offsetX = 0, angleZ = 0) {
        AudioSys.playLaser();
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.5), new THREE.MeshBasicMaterial({color: 0xccffff})); 
        l.position.copy(player.position);
        l.position.x += offsetX;
        l.position.z -= 1;
        l.rotation.y = -angleZ;
        l.userData.velocity = new THREE.Vector3(Math.sin(angleZ) * 20, 0, -Math.cos(angleZ) * 20);
        lasers.push(l);
        scene.add(l);
        l.updateMatrixWorld();
        shakeIntensity += 0.02;
    }
    
    function spawnPowerUp() {
        const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
        let mesh;
        
        if (type.name === 'SHIELD') {
             // RGB Pulsating Sphere for Armor
             mesh = new THREE.Group();
             const geo = new THREE.IcosahedronGeometry(0.5, 1);
             const matR = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
             mesh.add(new THREE.Mesh(geo, matR));
             const matG = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
             const mG = new THREE.Mesh(geo, matG); mG.scale.setScalar(0.85); mesh.add(mG);
             const matB = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
             const mB = new THREE.Mesh(geo, matB); mB.scale.setScalar(0.7); mesh.add(mB);
             mesh.userData.isRGB = true;
        } else {
            const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const mat = new THREE.MeshBasicMaterial({ color: type.color, wireframe: true });
            mesh = new THREE.Mesh(geo, mat);
            mesh.add(new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({ color: type.color })));
        }
        
        mesh.position.set((Math.random()-0.5)*8, -1.0, -100);
        mesh.userData = { type: type.name, label: type.label, color: type.color };
        powerUps.push(mesh);
        scene.add(mesh);
        mesh.updateMatrixWorld();
        lastPowerUpSpawnTime = performance.now();
    }
    
    function activatePowerUp(powerUpData) {
        AudioSys.playPowerUp();
        const hud = document.getElementById('powerup-display');
        hud.innerText = powerUpData.label;
        hud.style.color = '#' + powerUpData.color.toString(16);
        hud.className = "text-sm mt-2 font-bold powerup-active";
        spawnParticles(player.position, powerUpData.color);
        
        if (powerUpData.type === 'SHIELD') {
            playerState.shield = true;
            hullMesh.visible = true; // EQUIP ARMOR
            setTimeout(() => { hud.innerText = ""; }, 2000);
        } else {
            playerState.activePowerUp = powerUpData.type;
            playerState.powerUpEndTime = performance.now() + 10000; 
        }
    }

    function spawnEnemy(startPos = null, isBossMinion = false) {
        let geometry, mat, speedMult, rotSpeed, scoreVal;
        
        if (isBossMinion) {
            geometry = new THREE.OctahedronGeometry(0.4, 0);
            mat = new THREE.MeshBasicMaterial({ color: COLORS.neonYellow });
            speedMult = 0.09; 
            rotSpeed = {x: 0.1, y: 0.1};
            scoreVal = 50;
        } else {
            const typeConfig = ENEMY_CONFIGS[Math.floor(Math.random() * ENEMY_CONFIGS.length)];
            if (typeConfig.name === 'STANDARD') geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            else if (typeConfig.name === 'FAST') geometry = new THREE.OctahedronGeometry(0.6, 0);
            else geometry = new THREE.IcosahedronGeometry(0.7, 0);
            mat = new THREE.MeshBasicMaterial({ color: typeConfig.color, wireframe: true }); // Wireframe Enemies now
            speedMult = typeConfig.speed;
            rotSpeed = typeConfig.rot;
            scoreVal = typeConfig.score;
        }

        const mesh = new THREE.Mesh(geometry, mat);
        // Add glowing core
        const core = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: mat.color, transparent: true, opacity: 0.3}));
        core.scale.setScalar(0.5);
        mesh.add(core);

        mesh.userData = { speedMult, rotSpeed, scoreVal };
        
        if (startPos) mesh.position.copy(startPos);
        else {
            // Random spawn logic
            // If score > 5000 (after first boss), enemies can fly at different heights
            // otherwise, ground only.
            const use3DSpawn = score > 5000;
            const yPos = use3DSpawn ? (Math.random() * 5) - 1.5 : -1.0;
            // Clamp Y to playable area roughly -1.5 to 3.5
            const finalY = Math.max(-1.5, Math.min(3.5, yPos));
            
            mesh.position.set((Math.random()-0.5)*10, finalY, -100);
        }
        
        enemies.push(mesh);
        scene.add(mesh);
        mesh.updateMatrixWorld();
        lastEnemySpawnTime = performance.now();
    }
    
    function spawnParticles(pos, color) {
        const count = 12;
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
            mesh.userData.rotSpeed = new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2);
            mesh.userData.life = 1.0;
            scene.add(mesh);
            particles.push(mesh);
        }
    }
    
    function spawnHullDebris(pos) {
        const count = 8;
        // Flat triangles resembling panels
        const geo = new THREE.CircleGeometry(0.3, 3); 
        const mat = new THREE.MeshBasicMaterial({ color: COLORS.hullGrey, side: THREE.DoubleSide });
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            // Explode upwards and out
            mesh.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.8,
                Math.random() * 0.8,
                (Math.random() - 0.5) * 0.8
            );
            mesh.userData.rotSpeed = new THREE.Vector3(Math.random()*0.2, Math.random()*0.2, Math.random()*0.2);
            mesh.userData.life = 2.0;
            scene.add(mesh);
            particles.push(mesh);
        }
    }

    function checkCollisions() {
        if(isDying) return; // No collisions during death sequence
        
        const pBox = new THREE.Box3().setFromObject(player);
        
        for (let i = powerUps.length - 1; i >= 0; i--) {
            if (pBox.intersectsBox(new THREE.Box3().setFromObject(powerUps[i]))) {
                activatePowerUp(powerUps[i].userData);
                scene.remove(powerUps[i]); powerUps.splice(i, 1);
            }
        }
        
        if (boss) {
            if (pBox.intersectsBox(new THREE.Box3().setFromObject(boss))) {
                AudioSys.playExplosion();
                startDeathSequence();
            }
        }

        for (let i = lasers.length - 1; i >= 0; i--) {
            const lBox = new THREE.Box3().setFromObject(lasers[i]);
            let laserHit = false;
            
            if (boss && !laserHit) {
                 if (lBox.intersectsBox(new THREE.Box3().setFromObject(boss))) {
                     boss.userData.hp--;
                     AudioSys.playBass(AudioSys.ctx.currentTime, 50, 1.0); 
                     const pct = (boss.userData.hp / boss.userData.maxHp) * 100;
                     document.getElementById('boss-health-bar').style.width = pct + '%';
                     boss.children[0].material.color.setHex(0xffffff);
                     setTimeout(() => { if(boss) boss.children[0].material.color.setHex(COLORS.pink); }, 50);
                     spawnParticles(lasers[i].position, COLORS.white);
                     if (boss.userData.hp <= 0) destroyBoss();
                     scene.remove(lasers[i]); lasers.splice(i, 1);
                     laserHit = true;
                 }
            }
            
            if (laserHit) continue;

            for (let j = enemies.length - 1; j >= 0; j--) {
                if (lBox.intersectsBox(new THREE.Box3().setFromObject(enemies[j]))) {
                    AudioSys.playExplosion();
                    spawnParticles(enemies[j].position, enemies[j].material.color);
                    shakeIntensity += 0.1;
                    const enemyScore = enemies[j].userData.scoreVal || 100;
                    scene.remove(enemies[j]); enemies.splice(j, 1);
                    scene.remove(lasers[i]); lasers.splice(i, 1);
                    score += enemyScore; updateUI();
                    break;
                }
            }
        }
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            if (pBox.intersectsBox(new THREE.Box3().setFromObject(enemies[i]))) {
                if (playerState.shield) {
                    // Armor Break
                    AudioSys.playShieldBreak();
                    playerState.shield = false;
                    hullMesh.visible = false; // Hide Hull
                    spawnHullDebris(player.position); // Debris
                    spawnParticles(enemies[i].position, enemies[i].material.color);
                    
                    scene.remove(enemies[i]); enemies.splice(i, 1);
                    shakeIntensity += 1.5;
                    if(rgbPass) rgbPass.uniforms['amount'].value = 0.05;
                } else {
                    // Check HP
                    const now = performance.now();
                    if (now < playerInvulnerableUntil) return; // Ignore hit if invulnerable

                    playerHP--;
                    if (playerHP <= 0) {
                         // Fatal
                         AudioSys.playExplosion();
                         startDeathSequence();
                    } else {
                        // Damage Taken
                        AudioSys.playExplosion();
                        shakeIntensity += 1.0;
                        if(rgbPass) rgbPass.uniforms['amount'].value = 0.15;
                        playerInvulnerableUntil = now + 2000; // 2 seconds invulnerability
                        spawnHullDebris(player.position); // Visual flair
                        
                        // Flash red
                        frameMesh.material.color.setHex(0xff0000);
                        setTimeout(() => { if(!isDying && !isGameOver) frameMesh.material.color.setHex(COLORS.pink); }, 200);
                        
                        // Remove enemy
                        spawnParticles(enemies[i].position, enemies[i].material.color);
                        scene.remove(enemies[i]); enemies.splice(i, 1);
                    }
                }
            }
        }
    }

    function startDeathSequence() {
        isDying = true;
        deathStartTime = performance.now();
        shakeIntensity += 2.0; 
        if(rgbPass) rgbPass.uniforms['amount'].value = 0.2;
    }

    function updateUI() {
        document.getElementById('score-display').innerText = score;
        document.getElementById('missed-display').innerText = missedEnemies;
    }

    function gameOver(reason) {
        isGameOver = true; isGameRunning = false; isDying = false;
        AudioSys.stop();
        document.getElementById('overlay-title').innerText = `${reason}\nSCORE: ${score}`;
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('form-container').classList.remove('hidden');
        document.getElementById('agent-name-input').focus();
        document.getElementById('overlay-screen').style.display = 'flex';
        document.getElementById('instructions').style.display = 'none';
    }

    function startGame() {
        AudioSys.unlock(); 
        AudioSys.init(); 
        AudioSys.start();
        isGameOver = false; isGameRunning = true; isDying = false;
        score = 0; missedEnemies = 0; gameStartTime = performance.now();
        currentPhase = 0;
        shakeIntensity = 0;
        playerState.shield = false;
        playerState.activePowerUp = 'NONE';
        
        playerHP = 3; // Allow 2 hits (HP 3 -> 2 -> 1 -> Dead)
        playerInvulnerableUntil = 0;
        checkOrientation();
        
        // Reset Ship
        hullMesh.visible = false;
        // CHANGED: Reset color to Pink instead of Cyan
        frameMesh.material.color.setHex(COLORS.pink);
        
        document.getElementById('powerup-display').innerText = "";
        targetX = 0;
        targetY = -1.0;
        
        if (boss) { scene.remove(boss); boss = null; }
        document.getElementById('boss-hud').style.display = 'none';
        nextBossScoreThreshold = 5000;
        
        if(rgbPass) rgbPass.uniforms['amount'].value = 0.0015;
        setPhase(1);
        
        updateUI();
        document.getElementById('overlay-screen').style.display = 'none';
        enemies.forEach(e => scene.remove(e)); enemies.length = 0;
        lasers.forEach(l => scene.remove(l)); lasers.length = 0;
        particles.forEach(p => scene.remove(p)); particles.length = 0;
        powerUps.forEach(p => scene.remove(p)); powerUps.length = 0;
        player.position.set(0, -1.0, 0);
        player.updateMatrixWorld();
    }

    function onWindowResize() {
        const c = document.getElementById('game-container');
        camera.aspect = c.clientWidth / c.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(c.clientWidth, c.clientHeight);
        composer.setSize(c.clientWidth, c.clientHeight);
        checkOrientation();
    }

    let lastTime = 0;
    function animate(time) {
        requestAnimationFrame(animate);
        if(!lastTime) { lastTime = time; return; }
        const delta = (time - lastTime) / 1000;
        lastTime = time;

        updateGround(delta);

        if (isGameRunning) {
            const now = performance.now();
            
            if (isDying) {
                // Death Sequence Logic
                const deathProgress = (now - deathStartTime) / 1500; // 0.0 to 1.0
                
                // Glitch Colors: Flash Pink, Cyan, Neon Green
                const r = Math.random();
                if (r < 0.33) frameMesh.material.color.setHex(COLORS.pink);
                else if (r < 0.66) frameMesh.material.color.setHex(COLORS.cyan);
                else frameMesh.material.color.setHex(COLORS.neonGreen);
                
                // Shake
                player.position.x += (Math.random()-0.5) * 0.5;
                player.position.y += (Math.random()-0.5) * 0.5;
                
                // Bloat
                const scale = baseShipScale * (1.0 + deathProgress * 2.0); 
                player.scale.setScalar(scale);
                
                // RGB Pass Max
                if(rgbPass) rgbPass.uniforms['amount'].value = 0.05 + deathProgress * 0.2;

                if (deathProgress >= 1.0) {
                    spawnParticles(player.position, COLORS.cyan);
                    spawnParticles(player.position, COLORS.pink);
                    spawnHullDebris(player.position); // Final explosion
                    player.visible = false;
                    gameOver("CRITICAL FAILURE");
                }
                
                composer.render();
                return; // Skip rest of logic
            } else {
                // Blink if invulnerable
                if (now < playerInvulnerableUntil) {
                    player.visible = Math.floor(now / 100) % 2 === 0;
                } else {
                    player.visible = true;
                }
            }
            
            // Normal Game Logic inputs
            if (keys.left) targetX -= 25 * delta;
            if (keys.right) targetX += 25 * delta;
            if (keys.up) targetY += 25 * delta;
            if (keys.down) targetY -= 25 * delta;
            
            targetX = Math.max(-8, Math.min(8, targetX));
            targetY = Math.max(-1.5, Math.min(3.5, targetY));

            checkPhaseLogic(now);
            
            if (score >= nextBossScoreThreshold && !boss) {
                spawnBoss();
            }
            
            if (boss) {
                if (boss.position.z < -25) {
                    boss.position.z += 15 * delta;
                } else {
                    boss.userData.movePhase += delta;
                    boss.position.x = Math.sin(boss.userData.movePhase * 0.5) * 4;
                    boss.position.y = Math.sin(boss.userData.movePhase * 1.2) * 1.0 + 1.0;
                    boss.rotation.x += delta * 0.2;
                    boss.rotation.y += delta * 0.3;
                    
                    if (now - boss.userData.lastSpawn > 1500) {
                        spawnEnemy(boss.position, true);
                        boss.userData.lastSpawn = now;
                    }
                }
            }
            
            if (playerState.activePowerUp !== 'NONE' && now > playerState.powerUpEndTime) {
                playerState.activePowerUp = 'NONE';
                document.getElementById('powerup-display').innerText = "";
            }
            
            let fireRate = 250;
            if (playerState.activePowerUp === 'RAPID') fireRate = 100;
            
            if (keys.fire && now - lastFireTime > fireRate) {
                if (playerState.activePowerUp === 'SPREAD') {
                    createLaser(0, 0);
                    createLaser(-0.5, 0.1); 
                    createLaser(0.5, -0.1); 
                } else {
                    createLaser(0, 0);
                }
                lastFireTime = now;
            }
            
            player.position.x += (targetX - player.position.x) * 0.1;
            player.position.y += (targetY - player.position.y) * 0.1;
            player.rotation.z = (player.position.x - targetX) * 0.1;
            player.rotation.x = (player.position.y - targetY) * 0.1; 
            
            if (shakeIntensity > 0) {
                const shake = shakeIntensity;
                camera.position.x = (Math.random() - 0.5) * shake;
                camera.position.y = 1.0 + (Math.random() - 0.5) * shake;
                camera.position.z = 6 + (Math.random() - 0.5) * shake;
                shakeIntensity *= 0.9;
                if(shakeIntensity < 0.01) shakeIntensity = 0;
            } else {
                camera.position.set(0, 1.0, 6); 
            }

            if (rgbPass && rgbPass.uniforms['amount'].value > 0.002) {
                rgbPass.uniforms['amount'].value *= 0.9;
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.rotation.x += p.userData.rotSpeed.x;
                p.userData.life -= 2.0 * delta;
                p.material.opacity = p.userData.life;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            }

            for (let i = lasers.length - 1; i >= 0; i--) {
                if (lasers[i].userData.velocity) {
                    lasers[i].position.x += lasers[i].userData.velocity.x * delta;
                    lasers[i].position.z += lasers[i].userData.velocity.z * delta;
                } else {
                    lasers[i].position.z -= 20 * delta;
                }
                if (lasers[i].position.z < -100) { scene.remove(lasers[i]); lasers.splice(i, 1); }
            }
            
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                p.position.z += 10 * delta;
                if (p.userData.isRGB) {
                    p.children[0].rotation.x += delta * 2;
                    p.children[1].rotation.y += delta * 2;
                    p.children[2].rotation.z += delta * 2;
                    const s = 1.0 + Math.sin(now * 0.005) * 0.2;
                    p.scale.setScalar(s);
                } else {
                    p.rotation.x += delta;
                    p.rotation.y += delta;
                }
                if (p.position.z > 6) { scene.remove(p); powerUps.splice(i, 1); }
            }
            
            const baseSpeed = 0.025 + (now - gameStartTime) / 120000 * 0.06;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const moveSpeed = baseSpeed * (enemies[i].userData.speedMult || 1.0);
                enemies[i].position.z += moveSpeed * delta * 60 * 20; 
                if (enemies[i].userData.rotSpeed) {
                    enemies[i].rotation.x += enemies[i].userData.rotSpeed.x;
                    enemies[i].rotation.y += enemies[i].userData.rotSpeed.y;
                }
                if (enemies[i].position.z > 6) {
                    scene.remove(enemies[i]); enemies.splice(i, 1);
                    missedEnemies++; AudioSys.playBreach(); 
                    shakeIntensity += 0.3;
                    if(rgbPass) rgbPass.uniforms['amount'].value = 0.05;
                    updateUI();
                    if (missedEnemies >= 3) gameOver("SECURITY BREACH");
                }
            }

            if (!boss) {
                if (now - lastEnemySpawnTime > Math.max(600, 2500 - (now - gameStartTime)/120000*1900)) spawnEnemy();
            }
            
            if (now - lastPowerUpSpawnTime > 15000) { 
                if (Math.random() > 0.3) spawnPowerUp(); 
                else lastPowerUpSpawnTime = now;
            }
            
            checkCollisions();
        }
        composer.render();
    }
    init();
</script>
</body>
</html>