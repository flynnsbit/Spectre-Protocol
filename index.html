<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectre Protocol</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background-color: #0b0213;
        }
        
        #main-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            min-height: 80px;
            background: linear-gradient(to top, rgba(11, 2, 19, 0.95), rgba(11, 2, 19, 0.6));
            backdrop-filter: blur(4px);
            border-top: 2px solid #ff007f;
            z-index: 20;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            box-shadow: 0 -5px 20px rgba(255, 0, 127, 0.2);
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffc8;
            font-family: monospace;
            font-size: 1.2rem;
            z-index: 50;
            text-shadow: 0 0 5px #00ffc8;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-radius: 4px;
        }
        
        .breach-warning {
            color: #ff007f;
            font-weight: bold;
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0% { opacity: 0.7; text-shadow: 0 0 5px #ff007f; }
            50% { opacity: 1; text-shadow: 0 0 15px #ff007f; }
            100% { opacity: 0.7; text-shadow: 0 0 5px #ff007f; }
        }

        h1 {
            color: #ff007f;
            text-shadow: 0 0 10px #ff007f;
            font-size: 1.5rem;
            margin: 0;
            font-family: monospace;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            color: #ff007f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            backdrop-filter: blur(5px);
            padding-bottom: 140px;
            box-sizing: border-box;
        }
        
        .glitch-text {
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: 4px;
            text-shadow: 2px 2px #00ffc8;
            animation: glitch-effect 0.2s infinite alternate-reverse;
            margin-bottom: 1rem;
        }
        
        @keyframes glitch-effect {
            0% { transform: translate(1px, 1px); text-shadow: 2px 2px #00ffc8; }
            25% { transform: translate(-1px, -1px); text-shadow: -2px 2px #ff007f; }
            50% { transform: translate(-1px, 1px); text-shadow: 2px -2px #00ffc8; }
            100% { transform: translate(1px, -1px); text-shadow: -2px -2px #ff007f; }
        }
        
        .neon-button {
            background: #0b0213;
            color: #00ffc8;
            padding: 1rem 2.5rem;
            border-radius: 4px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border: 2px solid #00ffc8;
            box-shadow: 0 0 10px #00ffc8, inset 0 0 10px #00ffc8;
            transition: all 0.2s;
            margin-top: 20px;
            font-family: monospace;
            letter-spacing: 2px;
        }
        
        .neon-button:hover {
            background: #00ffc8;
            color: #0b0213;
            box-shadow: 0 0 20px #00ffc8, inset 0 0 20px #00ffc8;
        }

        .control-btn {
            background: transparent;
            border: 1px solid #ff007f;
            color: #ff007f;
            padding: 0.4rem 1rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: 0.2s;
            font-family: monospace;
            margin-left: 10px;
        }
        
        .control-btn:hover {
            background: #ff007f;
            color: white;
        }
        
        .leaderboard {
            width: 90%;
            max-width: 450px;
            margin-top: 20px;
            border: 2px solid #00ffc8;
            box-shadow: 0 0 15px #00ffc8;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffc8;
            max-height: 30vh;
            overflow-y: auto;
        }

        .leaderboard h3 {
            background: #00ffc8;
            color: #0b0213;
            padding: 8px;
            margin: 0;
            font-size: 1.1rem;
            text-shadow: none;
            position: sticky;
            top: 0;
        }
        
        .leaderboard table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .leaderboard th, .leaderboard td {
            padding: 6px 10px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 255, 200, 0.2);
        }
        
        .leaderboard tr:nth-child(even) {
            background: rgba(0, 255, 200, 0.05);
        }

        .leaderboard tr:hover {
            background: rgba(255, 0, 127, 0.1);
        }

        @media (max-width: 768px) {
            #ui-panel {
                flex-direction: column;
                padding: 1rem;
                gap: 0.5rem;
                min-height: 100px;
            }
            .control-group {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
            }
            .glitch-text { font-size: 2rem; }
            .leaderboard { width: 95%; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
            }
        }
    </script>
</head>
<body>

<div id="main-container">
    <div id="game-container">
        <div id="hud">
            <div>SCORE: <span id="score-display">0</span></div>
            <div class="mt-2 text-red-400">BREACHES: <span id="missed-display">0</span>/3</div>
            <div id="wave-display" class="text-xs mt-1 text-pink-500 opacity-80">PHASE: INITIALIZING</div>
        </div>
        
        <div id="overlay-screen">
            <p class="glitch-text" id="overlay-title">SPECTRE PROTOCOL</p>
            
            <div id="form-container" class="hidden w-full max-w-sm flex flex-col items-center mt-4 mb-4">
                 <p class="text-[#00ffc8] font-mono text-sm mb-2 tracking-widest animate-pulse">NEW HIGH SCORE DETECTED</p>
                 <div class="flex gap-2 w-full justify-center">
                    <input id="agent-name-input" type="text" maxlength="12" 
                           class="bg-gray-900/80 border-2 border-[#ff007f] text-[#ff007f] px-3 py-2 font-mono text-center uppercase focus:outline-none focus:border-[#00ffc8] focus:shadow-[0_0_10px_#00ffc8] transition-all w-48 placeholder-pink-900" 
                           placeholder="AGENT_ID">
                    <button id="submit-score-btn" class="bg-[#ff007f]/20 border-2 border-[#ff007f] text-[#ff007f] px-4 py-2 font-mono hover:bg-[#ff007f] hover:text-black transition-all font-bold">
                        UPLOAD
                    </button>
                 </div>
            </div>

            <div id="leaderboard-display" class="leaderboard">
                <h3>TOP 10 INTERCEPTORS</h3>
                <table>
                    <thead><tr><th>Rank</th><th>Agent</th><th>Score</th></tr></thead>
                    <tbody id="leaderboard-body">
                        <tr><td colspan="3" class="text-center text-xs text-pink-400">Loading Neural Link...</td></tr>
                    </tbody>
                </table>
            </div>
            <div id="instructions" class="text-center mt-6">
                <p class="text-white font-mono text-sm max-w-md p-2 mx-auto">
                    MISSION: INTERCEPT INCOMING DATA BLOCKS.
                </p>
                <p class="text-pink-500 font-mono text-xs mb-4">
                    WARNING: ALLOWING 3 ENEMIES TO PASS RESULTS IN SYSTEM FAILURE.
                </p>
                <div class="text-cyan-300 text-xs font-mono mb-6">
                    MOVE: WASD / ARROWS | FIRE: SPACE / CLICK
                </div>
            </div>
            <button id="start-btn" class="neon-button">INITIATE PROTOCOL</button>
        </div>
    </div>
    
    <div id="ui-panel">
        <div class="flex flex-col items-start">
            <h1>SPECTRE PROTOCOL</h1>
            <p id="sys-version" class="text-xs text-cyan-600 font-mono">SYS.VER.9.1 // VISUAL OVERDRIVE</p>
        </div>
        <div class="text-center hidden md:block">
            <div class="text-xs text-pink-500 font-mono animate-pulse">DATABASE LINK ESTABLISHED</div>
        </div>
        <div class="control-group flex items-center">
            <button id="mute-btn" class="control-btn">MUTE AUDIO</button>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { CopyShader } from 'three/addons/shaders/CopyShader.js';
    import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';

    import { initializeApp } from 'firebase/app';
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
    import { getFirestore, collection, query, orderBy, limit, onSnapshot, addDoc, serverTimestamp, setLogLevel } from 'firebase/firestore';

    // --- CONFIGURATION ---
    // FIREBASE CONFIGURATION FOR MULTI-USER LEADERBOARDS
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyDV7eXu5ERIic4pdE99qfoiH-_-uELJEgw",
      authDomain: "spectreprotocol-c21c5.firebaseapp.com",
      projectId: "spectreprotocol-c21c5",
      storageBucket: "spectreprotocol-c21c5.firebasestorage.app",
      messagingSenderId: "964619451248",
      appId: "1:964619451248:web:0adbc90162d36db6412db5",
      measurementId: "G-WFK1184JWY"
    };
    
    const FirebaseState = {
        db: null,
        auth: null,
        userId: null
    };

    // Check if config is provided via injection (dev env) or via the constant above (prod/github pages)
    const injectedConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
    
    let activeConfig = {};
    if (injectedConfig && injectedConfig !== '{}') {
        activeConfig = JSON.parse(injectedConfig);
    } else if (Object.keys(FIREBASE_CONFIG).length > 0) {
        activeConfig = FIREBASE_CONFIG;
    }

    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    if (Object.keys(activeConfig).length > 0 && activeConfig.apiKey) {
        try {
            const app = initializeApp(activeConfig);
            FirebaseState.db = getFirestore(app);
            FirebaseState.auth = getAuth(app);
            setLogLevel('error');
        } catch (e) {
            console.error("Firebase Init Error:", e);
        }
    }

    async function initializeFirebase() {
        const auth = FirebaseState.auth;
        if (!auth) {
            // Explicitly trigger fallback if no auth
            setupLeaderboardListener();
            return;
        }
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase authentication failed:", error);
            FirebaseState.userId = crypto.randomUUID();
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                FirebaseState.userId = user.uid;
                setupLeaderboardListener();
            } else {
                FirebaseState.userId = crypto.randomUUID();
                setupLeaderboardListener();
            }
        });
    }

    function getScoresCollectionRef() {
        return collection(FirebaseState.db, `artifacts/${appId}/public/data/scores`);
    }

    function setupLeaderboardListener() {
        if (!FirebaseState.db) {
            // Local Storage Fallback
            console.log("Using Local Storage for Leaderboard");
            const localScores = JSON.parse(localStorage.getItem('spectre_local_leaderboard') || '[]');
            if (localScores.length === 0) {
                 // Initial Dummy Data so it looks cool
                 localScores.push(
                     {name: 'SPECTRE', score: 5000},
                     {name: 'GHOST', score: 3500},
                     {name: 'PHANTOM', score: 2000}
                 );
                 localStorage.setItem('spectre_local_leaderboard', JSON.stringify(localScores));
            }
            renderLeaderboard(localScores.sort((a, b) => b.score - a.score));
            
            document.getElementById('sys-version').innerText = "SYS.VER.9.1 // LOCAL STORAGE";
            return;
        }
        
        document.getElementById('sys-version').innerText = "SYS.VER.9.1 // CLOUD SYNC";
        const scoresQuery = query(getScoresCollectionRef(), orderBy('score', 'desc'), limit(10));
        
        onSnapshot(scoresQuery, (snapshot) => {
            renderLeaderboard(snapshot.docs.map(doc => doc.data()));
        }, (error) => {
            console.error("Leaderboard sync error:", error);
            // Fallback to local if cloud fails mid-game
            document.getElementById('sys-version').innerText = "SYS.VER.9.1 // SYNC ERROR";
        });
    }

    function renderLeaderboard(scores) {
        const body = document.getElementById('leaderboard-body');
        body.innerHTML = '';
        if (scores.length === 0) {
            body.innerHTML = `<tr><td colspan="3" class="text-center text-xs text-pink-400">No scores yet.</td></tr>`;
            return;
        }
        scores.forEach((s, index) => {
            const row = body.insertRow();
            row.insertCell(0).innerText = index + 1;
            row.insertCell(1).innerText = s.name ? s.name.substring(0, 12) : 'UNKNOWN';
            row.insertCell(2).innerText = s.score;
        });
    }

    function submitScore() {
        const input = document.getElementById('agent-name-input');
        const name = input.value.trim().toUpperCase() || 'ANONYMOUS';
        const finalScore = score;

        if (FirebaseState.db) {
            addDoc(getScoresCollectionRef(), {
                name: name,
                score: finalScore,
                timestamp: serverTimestamp(),
                userId: FirebaseState.userId,
            }).then(() => {
                 localStorage.setItem('spectre_agent_name', name);
                 resetOverlayToStart();
            }).catch(e => {
                console.error("Score upload failed", e);
                // Fallback save to local
                saveLocalScore(name, finalScore);
                resetOverlayToStart();
            });
        } else {
            saveLocalScore(name, finalScore);
            resetOverlayToStart();
        }
    }
    
    function saveLocalScore(name, finalScore) {
        const localScores = JSON.parse(localStorage.getItem('spectre_local_leaderboard') || '[]');
        localScores.push({ name: name, score: finalScore, timestamp: Date.now() });
        localScores.sort((a, b) => b.score - a.score);
        const top10 = localScores.slice(0, 10);
        localStorage.setItem('spectre_local_leaderboard', JSON.stringify(top10));
        renderLeaderboard(top10);
        localStorage.setItem('spectre_agent_name', name);
    }
    
    function resetOverlayToStart() {
        document.getElementById('form-container').classList.add('hidden');
        const btn = document.getElementById('start-btn');
        btn.innerText = "RE-INITIALIZE";
        btn.style.display = 'block';
    }

    // --- FULL EDM AUDIO ENGINE ---
    const AudioSys = {
        ctx: null, isMuted: false, isPlaying: false,
        nextNoteTime: 0, tempo: 128, lookahead: 25.0, scheduleAheadTime: 0.1, timerID: null, measure: 0, beat: 0,
        
        init: function() {
            if (!this.ctx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            }
        },
        
        unlock: function() {
            if (!this.ctx) this.init();
            const buffer = this.ctx.createBuffer(1, 1, 22050);
            const source = this.ctx.createBufferSource();
            source.buffer = buffer;
            source.connect(this.ctx.destination);
            source.start(0);
            if (this.ctx.state === 'suspended') {
                this.ctx.resume().then(() => {
                    console.log("Audio Context Resumed via Unlock");
                });
            }
        },

        toggleMute: function() {
            this.isMuted = !this.isMuted;
            if (this.isMuted) { if(this.ctx) this.ctx.suspend(); } 
            else { if(this.ctx) this.ctx.resume(); }
            return this.isMuted;
        },
        
        playTone: function(freq, type, len, time, vol=0.1) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(vol, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + len);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + len);
        },

        playNoise: function(len, filterFreq, time) {
            if (this.isMuted || !this.ctx) return;
            const bufferSize = this.ctx.sampleRate * len;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = filterFreq;
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + len);
            noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            noise.start(time);
        },
        
        playKick: function(time) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.5);
        },
        
        playSnare: function(time) { this.playNoise(0.1, 1000, time); },
        playHiHat: function(time, open = false) { this.playNoise(open ? 0.1 : 0.05, 8000, time); },

        playBass: function(time, freq, intensity = 0) {
             if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, time);
            filter.type = 'lowpass';
            const baseFreq = 200 + (intensity * 2000);
            filter.frequency.setValueAtTime(baseFreq, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + 0.2);
            gain.gain.setValueAtTime(0.15, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
            osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.3);
        },

        playLead: function(time, freq) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(freq, time);
            osc.frequency.linearRampToValueAtTime(freq + 5, time + 0.1);
            gain.gain.setValueAtTime(0.05, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.3);
        },

        // Riser for build ups
        playRiser: function(time, pitch) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(pitch, time);
            osc.frequency.linearRampToValueAtTime(pitch + 100, time + 0.1);
            gain.gain.setValueAtTime(0.05, time);
            gain.gain.linearRampToValueAtTime(0.01, time + 0.1);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(time); osc.stop(time + 0.1);
        },
        
        scheduleNote: function(beatNumber, time) {
            const gameTime = (performance.now() - gameStartTime) / 1000;
            
            // Phase Logic for Audio
            // Phase 1: 0-30s (Normal)
            // Phase 2: 30-60s (Hard)
            // Phase 3: 60s+ (Overdrive)
            
            const phaseInterval = 30; 
            const timeInPhase = gameTime % phaseInterval;
            const isBuildUp = (timeInPhase > 26 && gameTime > 10); // Last 4 seconds of any phase is a build up
            
            // Build Up Logic (Snare Roll + Riser)
            if (isBuildUp) {
                // Snare roll increases in density
                // 26-28s: Quarter notes
                // 28-29s: 8th notes
                // 29-30s: 16th notes
                let playRoll = false;
                if (timeInPhase < 28 && beatNumber % 4 === 0) playRoll = true;
                else if (timeInPhase >= 28 && timeInPhase < 29 && beatNumber % 2 === 0) playRoll = true;
                else if (timeInPhase >= 29) playRoll = true;
                
                if (playRoll) {
                    this.playSnare(time);
                    this.playRiser(time, 200 + (timeInPhase - 26) * 200); // Rising pitch
                }
                // Mute bass/kick during build up for drop impact
                return; 
            }

            // Regular Beat Logic
            
            // Kick
            if (beatNumber % 4 === 0) this.playKick(time);
            
            // Snare (Backbeat)
            if (beatNumber === 4 || beatNumber === 12) this.playSnare(time);
            
            // HiHats
            // More hats in later phases
            if (gameTime > 10) {
                if (gameTime > 60) { // Overdrive hats
                     this.playHiHat(time, beatNumber % 4 === 2); // Open hat on off-beat
                     if (beatNumber % 2 !== 0) this.playHiHat(time, false); // Closed hats in between
                } else if (gameTime > 30) { // Hard hats
                    this.playHiHat(time, beatNumber % 4 === 2);
                } else if (beatNumber % 2 === 0) {
                    this.playHiHat(time);
                }
            }
            
            // Bass
            // Drop Logic: Bass is heavy in the middle of phases, not at start
            if (gameTime > 5) {
                 const bassRoot = [55, 55, 65.4, 43.6][Math.floor((this.measure % 4))]; 
                 const bassIntensity = Math.min(1, gameTime / 90);
                 
                 // Syncopated bass rhythm
                 if (beatNumber === 0 || beatNumber === 3 || beatNumber === 7 || beatNumber === 10) {
                     this.playBass(time, bassRoot, bassIntensity);
                 }
            }
            
            // Lead Arp (Enter in Hard Phase)
            if (gameTime > 30 && beatNumber % 2 === 0) {
                const arpNotes = [440, 523, 659, 880];
                // Random arp in Hard, Fast arp in Overdrive
                if (gameTime > 60 || Math.random() > 0.5) {
                    this.playLead(time, arpNotes[Math.floor(Math.random()*arpNotes.length)]);
                }
            }
        },
        
        scheduler: function() {
            while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.beat, this.nextNoteTime);
                const secondsPerBeat = 60.0 / this.tempo / 4;
                this.nextNoteTime += secondsPerBeat;
                this.beat++;
                if (this.beat === 16) { this.beat = 0; this.measure++; }
            }
            this.timerID = window.setTimeout(this.scheduler.bind(this), this.lookahead);
        },
        start: function() {
            if (this.isPlaying) return;
            this.isPlaying = true; this.beat = 0; this.measure = 0;
            this.tempo = 128; // Reset tempo
            this.nextNoteTime = this.ctx.currentTime + 0.1;
            this.scheduler();
        },
        stop: function() {
            this.isPlaying = false; window.clearTimeout(this.timerID);
        },
        
        playLaser: function() { 
            if (this.isMuted || !this.ctx) return;
            this.playTone(880, 'square', 0.1, this.ctx.currentTime, 0.1);
        },
        playExplosion: function() {
             if (this.isMuted || !this.ctx) return;
             for(let i=0; i<3; i++) {
                 this.playBass(this.ctx.currentTime, 30 + Math.random() * 40, 1.0); 
             }
        },
        playBreach: function() {
            if (this.isMuted || !this.ctx) return;
            this.playTone(150, 'sawtooth', 0.5, this.ctx.currentTime, 0.5);
        }
    };

    let scene, camera, renderer, composer, rgbPass;
    let player, groundMesh1, groundMesh2;
    const lasers = [];
    const enemies = [];
    const particles = [];
    const keys = { left: false, right: false };
    let score = 0, missedEnemies = 0, isGameOver = false, isGameRunning = false, gameStartTime = 0;
    let currentPhase = 0; // 0: Init, 1: Normal, 2: Hard, 3: Overdrive
    let spawnInterval = 2500, lastEnemySpawnTime = 0, targetX = 0;
    let shakeIntensity = 0;
    
    const COLORS = { 
        cyan: 0x00ffc8, 
        pink: 0xff007f, 
        dark: 0x0b0213, 
        neonGreen: 0x00ff41, 
        neonCyan: 0x00ffff,
        neonMagenta: 0xff00ff,
        darkGreen: 0x004411 
    };
    const GROUND_SIZE = 200;
    
    const ENEMY_CONFIGS = [
        { name: 'STANDARD', color: 0xff007f, speed: 1.0, rot: {x: 0.02, y: 0.02}, score: 100 },
        { name: 'FAST', color: 0x00ffc8, speed: 1.5, rot: {x: 0.0, y: 0.1}, score: 150 },
        { name: 'HEAVY', color: 0xff2a00, speed: 0.7, rot: {x: 0.005, y: 0.005}, score: 200 }
    ];

    function init() {
        initializeFirebase();
        const container = document.getElementById('game-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.dark);
        scene.fog = new THREE.FogExp2(COLORS.dark, 0.02); 

        camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.0, 6); 
        camera.rotation.x = -0.1;

        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(COLORS.pink, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(COLORS.pink, 1);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        createGround();
        createPlayerShip();
        createStarfield();
        setupPostProcessing(container.clientWidth, container.clientHeight);

        window.addEventListener('resize', onWindowResize);
        container.addEventListener('mousemove', (e) => {
             const rect = renderer.domElement.getBoundingClientRect();
             targetX = ((e.clientX - rect.left) / rect.width * 2 - 1) * 8;
        });
        container.addEventListener('click', () => { if(isGameRunning) createLaser(); });

        window.addEventListener('keydown', (e) => {
            if(!isGameRunning) return;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') { keys.left = true; }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') { keys.right = true; }
            if (e.code === 'Space') {
                if (!e.repeat) createLaser();
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
        });

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('submit-score-btn').addEventListener('click', submitScore);
        
        document.getElementById('mute-btn').addEventListener('click', (e) => {
            e.target.innerText = AudioSys.toggleMute() ? "UNMUTE AUDIO" : "MUTE AUDIO";
        });
        
        document.body.addEventListener('touchstart', function() {
             if(AudioSys.ctx && AudioSys.ctx.state === 'suspended') {
                 AudioSys.unlock();
             }
        }, { once: true });
        
        const savedName = localStorage.getItem('spectre_agent_name');
        if(savedName) document.getElementById('agent-name-input').value = savedName;
        
        setTimeout(() => {
            if (!FirebaseState.db) {
                setupLeaderboardListener();
            }
        }, 1000);

        animate(0);
    }

    function setupPostProcessing(w, h) {
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Bloom
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(w, h), 0.75, 0.5, 0.2));
        
        // RGB Shift (Glitch)
        rgbPass = new ShaderPass(RGBShiftShader);
        rgbPass.uniforms['amount'].value = 0.0015; // Minimal default shift
        composer.addPass(rgbPass);

        composer.addPass(new ShaderPass(CopyShader));
    }

    function createGround() {
        const width = 150;
        const length = GROUND_SIZE;
        const segmentsW = 50;
        const segmentsH = 50;
        const geo = new THREE.PlaneGeometry(width, length, segmentsW, segmentsH);
        
        const posAttribute = geo.attributes.position;
        const vertex = new THREE.Vector3();
        
        for (let i = 0; i < posAttribute.count; i++) {
            vertex.fromBufferAttribute(posAttribute, i);
            const distFromCenter = Math.abs(vertex.x);
            const safeZone = 15; 
            
            if (distFromCenter > safeZone) {
                const rise = Math.pow((distFromCenter - safeZone) / 4, 2.5);
                const noise = Math.random() * 2.5;
                vertex.z += rise + noise;
            }
            posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        geo.computeVertexNormals();

        // Initial Color: Neon Green
        const mat = new THREE.MeshBasicMaterial({ 
            color: COLORS.neonGreen, 
            wireframe: true, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3
        });

        groundMesh1 = new THREE.Mesh(geo, mat);
        groundMesh1.rotation.x = -Math.PI / 2;
        groundMesh1.position.set(0, -2, -GROUND_SIZE/2 + 6); 
        scene.add(groundMesh1);

        groundMesh2 = new THREE.Mesh(geo, mat);
        groundMesh2.rotation.x = -Math.PI / 2;
        groundMesh2.position.set(0, -2, -GROUND_SIZE/2 + 6 - GROUND_SIZE); 
        scene.add(groundMesh2);
    }

    function updateGround(delta) {
        const speed = 20 * delta;
        groundMesh1.position.z += speed;
        groundMesh2.position.z += speed;

        if (groundMesh1.position.z > 6 + GROUND_SIZE/2) groundMesh1.position.z -= GROUND_SIZE * 2;
        if (groundMesh2.position.z > 6 + GROUND_SIZE/2) groundMesh2.position.z -= GROUND_SIZE * 2;
    }
    
    function setPhase(p) {
        currentPhase = p;
        const hud = document.getElementById('wave-display');
        
        // THE DROP: Change colors and tempo
        if (p === 1) {
            // Phase 1 (Green) - Normal
            hud.innerText = "PHASE: PROTOCOL START";
            hud.className = "text-xs mt-1 text-[#00ff41] opacity-80";
            groundMesh1.material.color.setHex(COLORS.neonGreen);
            AudioSys.tempo = 128;
        } else if (p === 2) {
            // Phase 2 (Cyan) - Hard
            hud.innerText = "PHASE: HARDLINE";
            hud.className = "text-xs mt-1 text-[#00ffff] opacity-100 font-bold";
            groundMesh1.material.color.setHex(COLORS.neonCyan);
            AudioSys.tempo = 138;
            // Flash effect
            composer.passes[1].strength = 3.0; // Bloom spike
            setTimeout(() => { composer.passes[1].strength = 0.75; }, 500);
        } else if (p === 3) {
            // Phase 3 (Magenta) - Overdrive
            hud.innerText = "PHASE: SYSTEM OVERDRIVE";
            hud.className = "text-xs mt-1 text-[#ff00ff] opacity-100 font-bold animate-pulse";
            groundMesh1.material.color.setHex(COLORS.neonMagenta);
            AudioSys.tempo = 150;
             // Flash effect
            composer.passes[1].strength = 4.0;
            setTimeout(() => { composer.passes[1].strength = 0.75; }, 500);
        }
    }
    
    function checkPhaseLogic(now) {
        const time = (now - gameStartTime) / 1000;
        
        if (time < 30) {
            if (currentPhase !== 1) setPhase(1);
        } else if (time < 60) {
            if (currentPhase !== 2) setPhase(2);
        } else {
            if (currentPhase !== 3) setPhase(3);
        }
    }

    function createStarfield() {
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<2000; i++) pos.push((Math.random()-0.5)*200, (Math.random()-0.5)*100, (Math.random()-0.5)*200);
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({size: 0.1, color: 0xffffff});
        scene.add(new THREE.Points(geo, mat));
    }

    function createPlayerShip() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.2, 3), new THREE.MeshBasicMaterial({color: 0xff007f}));
        body.rotation.x = Math.PI / 2;
        body.rotation.z = Math.PI;
        group.add(body);

        const engineGeo = new THREE.BoxGeometry(0.6, 0.1, 0.1);
        const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffc8 });
        const engine = new THREE.Mesh(engineGeo, engineMat);
        engine.position.set(0, 0, 0.5);
        group.add(engine);

        player = group;
        player.position.set(0, -1.0, 0);
        scene.add(player);
    }

    function createLaser() {
        AudioSys.playLaser();
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.5), new THREE.MeshBasicMaterial({color: 0xccffff})); 
        l.position.copy(player.position);
        l.position.z -= 1;
        lasers.push(l);
        scene.add(l);
        
        // Kickback shake
        shakeIntensity += 0.02;
    }

    function spawnEnemy() {
        const typeConfig = ENEMY_CONFIGS[Math.floor(Math.random() * ENEMY_CONFIGS.length)];
        
        let geometry;
        if (typeConfig.name === 'STANDARD') geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        else if (typeConfig.name === 'FAST') geometry = new THREE.OctahedronGeometry(0.6, 0);
        else geometry = new THREE.IcosahedronGeometry(0.7, 0);

        const mat = new THREE.MeshBasicMaterial({ color: typeConfig.color }); 
        const mesh = new THREE.Mesh(geometry, mat);
        
        const edges = new THREE.LineSegments(
            new THREE.EdgesGeometry(geometry), 
            new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 })
        );
        mesh.add(edges);

        mesh.userData = { 
            speedMult: typeConfig.speed, 
            rotSpeed: typeConfig.rot,
            scoreVal: typeConfig.score 
        };
        
        mesh.position.set((Math.random()-0.5)*10, -1.0, -100);
        enemies.push(mesh);
        scene.add(mesh);
        lastEnemySpawnTime = performance.now();
    }
    
    function spawnParticles(pos, color) {
        const count = 12;
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
        
        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            
            mesh.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            mesh.userData.rotSpeed = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
            );
            mesh.userData.life = 1.0;
            
            scene.add(mesh);
            particles.push(mesh);
        }
    }

    function checkCollisions() {
        const pBox = new THREE.Box3().setFromObject(player);
        for (let i = lasers.length - 1; i >= 0; i--) {
            const lBox = new THREE.Box3().setFromObject(lasers[i]);
            for (let j = enemies.length - 1; j >= 0; j--) {
                if (lBox.intersectsBox(new THREE.Box3().setFromObject(enemies[j]))) {
                    AudioSys.playExplosion();
                    spawnParticles(enemies[j].position, enemies[j].material.color);
                    
                    // Impact Shake
                    shakeIntensity += 0.1;
                    
                    const enemyScore = enemies[j].userData.scoreVal || 100;
                    scene.remove(enemies[j]); enemies.splice(j, 1);
                    scene.remove(lasers[i]); lasers.splice(i, 1);
                    score += enemyScore; updateUI();
                    break;
                }
            }
        }
        for (const e of enemies) {
            if (pBox.intersectsBox(new THREE.Box3().setFromObject(e))) {
                AudioSys.playExplosion();
                shakeIntensity += 1.0; // Major crash
                if(rgbPass) rgbPass.uniforms['amount'].value = 0.1; // Major Glitch
                gameOver("IMPACT DETECTED");
            }
        }
    }

    function updateUI() {
        document.getElementById('score-display').innerText = score;
        document.getElementById('missed-display').innerText = missedEnemies;
    }

    function gameOver(reason) {
        isGameOver = true; isGameRunning = false;
        AudioSys.stop();
        document.getElementById('overlay-title').innerText = `${reason}\nSCORE: ${score}`;
        
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('form-container').classList.remove('hidden');
        document.getElementById('agent-name-input').focus();

        document.getElementById('overlay-screen').style.display = 'flex';
        document.getElementById('instructions').style.display = 'none';
    }

    function startGame() {
        AudioSys.unlock(); 
        AudioSys.init(); 
        AudioSys.start();
        isGameOver = false; isGameRunning = true;
        score = 0; missedEnemies = 0; gameStartTime = performance.now();
        currentPhase = 0;
        shakeIntensity = 0;
        if(rgbPass) rgbPass.uniforms['amount'].value = 0.0015;
        setPhase(1); // Reset to green
        
        updateUI();
        document.getElementById('overlay-screen').style.display = 'none';
        enemies.forEach(e => scene.remove(e)); enemies.length = 0;
        lasers.forEach(l => scene.remove(l)); lasers.length = 0;
        particles.forEach(p => scene.remove(p)); particles.length = 0;
        player.position.set(0, -1.0, 0);
    }

    function onWindowResize() {
        const c = document.getElementById('game-container');
        camera.aspect = c.clientWidth / c.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(c.clientWidth, c.clientHeight);
        composer.setSize(c.clientWidth, c.clientHeight);
    }

    let lastTime = 0;
    function animate(time) {
        requestAnimationFrame(animate);
        if(!lastTime) { lastTime = time; return; }
        const delta = (time - lastTime) / 1000;
        lastTime = time;

        updateGround(delta);

        if (isGameRunning) {
            if (keys.left) targetX -= 25 * delta;
            if (keys.right) targetX += 25 * delta;
            targetX = Math.max(-8, Math.min(8, targetX));

            const now = performance.now();
            checkPhaseLogic(now);
            
            player.position.x += (targetX - player.position.x) * 0.1;
            player.rotation.z = (player.position.x - targetX) * 0.1;
            
            // Camera Shake
            if (shakeIntensity > 0) {
                const shake = shakeIntensity;
                camera.position.x = (Math.random() - 0.5) * shake;
                camera.position.y = 1.0 + (Math.random() - 0.5) * shake;
                camera.position.z = 6 + (Math.random() - 0.5) * shake;
                shakeIntensity *= 0.9;
                if(shakeIntensity < 0.01) shakeIntensity = 0;
            } else {
                camera.position.set(0, 1.0, 6); 
            }

            // Glitch Decay
            if (rgbPass && rgbPass.uniforms['amount'].value > 0.002) {
                rgbPass.uniforms['amount'].value *= 0.9;
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.rotation.x += p.userData.rotSpeed.x;
                p.rotation.y += p.userData.rotSpeed.y;
                p.userData.life -= 2.0 * delta;
                p.material.opacity = p.userData.life;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            for (let i = lasers.length - 1; i >= 0; i--) {
                lasers[i].position.z -= 20 * delta;
                if (lasers[i].position.z < -100) { scene.remove(lasers[i]); lasers.splice(i, 1); }
            }
            
            const baseSpeed = 0.025 + (now - gameStartTime) / 120000 * 0.06;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const moveSpeed = baseSpeed * (enemies[i].userData.speedMult || 1.0);
                enemies[i].position.z += moveSpeed * delta * 60 * 20; 
                
                if (enemies[i].userData.rotSpeed) {
                    enemies[i].rotation.x += enemies[i].userData.rotSpeed.x;
                    enemies[i].rotation.y += enemies[i].userData.rotSpeed.y;
                }

                if (enemies[i].position.z > 6) {
                    scene.remove(enemies[i]); enemies.splice(i, 1);
                    missedEnemies++; AudioSys.playBreach(); 
                    
                    // Breach Effects
                    shakeIntensity += 0.3;
                    if(rgbPass) rgbPass.uniforms['amount'].value = 0.05;
                    
                    updateUI();
                    if (missedEnemies >= 3) gameOver("SECURITY BREACH");
                }
            }

            if (now - lastEnemySpawnTime > Math.max(600, 2500 - (now - gameStartTime)/120000*1900)) spawnEnemy();
            checkCollisions();
        }
        composer.render();
    }
    init();
</script>
</body>
</html>